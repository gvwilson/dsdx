<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Conflict-Free Replicated Data Types (CRDTs)</title>
<link href="../static/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="../static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../static/page.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav>
<a href="../">Home</a>
      ·
      <span class="dropdown">
<a href="#">Lessons</a>
<span class="dropdown-content" id="nav-lessons">
<a href="../intro/">Introduction</a>
<a href="../oauth/">OAuth</a>
<a href="../msgque/">A Message Queue</a>
<a href="../distlock/">Distributed Locks</a>
<a href="../eventual/">Eventually Consistent Key-Value Store</a>
<a href="../mapreduce/">MapReduce</a>
<a href="../worksteal/">Work-Stealing Scheduler</a>
<a href="../crdt/">Conflict-Free Replicated Data Types</a>
<a href="../torrent/">BitTorrent</a>
<a href="../finale/">Conclusion</a>
</span>
</span>
      ·
      <span class="dropdown">
<a href="#">Appendices</a>
<span class="dropdown-content" id="nav-appendices">
<a href="../license/">License</a>
<a href="../conduct/">Code of Conduct</a>
<a href="../contributing/">Contributing</a>
<a href="../bibliography/">Bibliography</a>
<a href="../glossary/">Glossary</a>
</span>
</span>
</nav>
<main>
<h1>Conflict-Free Replicated Data Types (CRDTs)</h1>
<p>When multiple people edit a Google Doc simultaneously, how does the system ensure everyone eventually sees the same content?
When you edit a document offline on your phone and someone else edits it on their laptop, how do the changes merge when you reconnect?
Traditional approaches use locking or operational transformation, but these require coordination and can fail during network partitions.</p>
<p>Conflict-Free Replicated Data Types (CRDTs) solve this problem through mathematics rather than coordination.
CRDTs are data structures designed so that concurrent updates on different replicas can always be merged automatically, without conflicts, and all replicas eventually converge to the same state.
No consensus protocol needed.
No locking required.
Updates are always accepted immediately.</p>
<p>This pattern appears throughout modern distributed systems: Google Docs uses CRDTs for collaborative editing, Figma for real-time design collaboration, Riak for distributed databases, and Redis for geo-replicated caches.
Understanding CRDTs is essential for building partition-tolerant, offline-first applications.</p>
<h2>The CRDT Promise</h2>
<p>CRDTs make a powerful guarantee: <strong>Strong Eventual Consistency</strong>.
This means:</p>
<ol>
<li><strong>Eventual delivery</strong>: Every update reaches every replica eventually</li>
<li><strong>Convergence</strong>: Replicas that have received the same updates are in the same state</li>
<li><strong>No conflicts</strong>: Concurrent updates can always be merged automatically</li>
</ol>
<p>The key insight is that some operations are <strong>commutative</strong> and <strong>associative</strong>:
- Commutative: A + B = B + A (order doesn't matter)
- Associative: (A + B) + C = A + (B + C) (grouping doesn't matter)</p>
<p>If your merge operation has these properties, replicas can receive updates in any order and still converge to the same state.</p>
<h2>Two Flavors: State-Based vs Operation-Based</h2>
<p>There are two main CRDT approaches:</p>
<p><strong>State-based CRDTs (CvRDTs)</strong>: Replicas send their entire state and merge states
- Simple to reason about
- Higher network overhead (sending full state)
- Merge must be commutative, associative, and idempotent</p>
<p><strong>Operation-based CRDTs (CmRDTs)</strong>: Replicas send operations (deltas) and apply them
- Lower network overhead (sending just operations)
- Requires exactly-once delivery of operations
- Operations must commute</p>
<p>We'll implement both approaches to understand the trade-offs.</p>
<h2>Grow-Only Counter (G-Counter)</h2>
<p>Let's start with the simplest CRDT: a counter that can only increase.
Each replica maintains a vector of counters, one per replica:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GCounter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Grow-only counter (state-based CRDT)."""</span>
    <span class="n">replica_id</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">counts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Increment this replica's counter."""</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span> <span class="o">+</span> <span class="n">amount</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Get the total count across all replicas."""</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">'GCounter'</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Merge another counter's state (take max of each replica)."""</span>
        <span class="n">all_replicas</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="n">all_replicas</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">replica</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">replica</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">other</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">replica</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">'GCounter'</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Create a copy of this counter."""</span>
        <span class="k">return</span> <span class="n">GCounter</span><span class="p">(</span>
            <span class="n">replica_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="p">,</span>
            <span class="n">counts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"GCounter(id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">, value=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">, counts=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="si">}</span><span class="s2">)"</span>
</code></pre></div>
<p>The G-Counter works by having each replica only modify its own entry in the vector.
When merging, we take the maximum of each entry—this is commutative, associative, and idempotent, guaranteeing convergence.</p>
<h2>PN-Counter: Positive-Negative Counter</h2>
<p>A grow-only counter is limited.
What about decrement?
We use two G-Counters: one for increments, one for decrements:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PNCounter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Positive-Negative counter supporting increment and decrement."""</span>
    <span class="n">replica_id</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">increments</span><span class="p">:</span> <span class="n">GCounter</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">GCounter</span><span class="p">(</span><span class="s2">""</span><span class="p">))</span>
    <span class="n">decrements</span><span class="p">:</span> <span class="n">GCounter</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">GCounter</span><span class="p">(</span><span class="s2">""</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increments</span><span class="o">.</span><span class="n">replica_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decrements</span><span class="o">.</span><span class="n">replica_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Increment the counter."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increments</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">decrement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Decrement the counter."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decrements</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Get the current value (increments - decrements)."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">increments</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrements</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">'PNCounter'</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Merge another counter's state."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increments</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">increments</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decrements</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">decrements</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">'PNCounter'</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Create a copy of this counter."""</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">PNCounter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">increments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">increments</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">decrements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrements</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"PNCounter(id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">, value=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">)"</span>
</code></pre></div>
<p>This works because increments and decrements are tracked separately.
Each remains monotonically increasing, so the G-Counter merge properties still apply.</p>
<h2>Last-Write-Wins Register (LWW-Register)</h2>
<p>For values that should be overwritten (like a user's profile name), we use timestamps to determine which write wins:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">LWWRegister</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Last-Write-Wins register (state-based CRDT)."""</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">any</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">timestamp</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">replica_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">any</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">replica_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Set the value with a timestamp."""</span>
        <span class="c1"># Use timestamp to break ties, replica_id for determinism</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">timestamp</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="ow">or</span> 
            <span class="p">(</span><span class="n">timestamp</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="ow">and</span> <span class="n">replica_id</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">timestamp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span> <span class="o">=</span> <span class="n">replica_id</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">'LWWRegister'</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Merge another register (keep higher timestamp)."""</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="ow">and</span> 
             <span class="n">other</span><span class="o">.</span><span class="n">replica_id</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">replica_id</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">'LWWRegister'</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Create a copy of this register."""</span>
        <span class="k">return</span> <span class="n">LWWRegister</span><span class="p">(</span>
            <span class="n">value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">timestamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span>
            <span class="n">replica_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"LWWRegister(value=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">, ts=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">)"</span>
</code></pre></div>
<p>LWW-Register has a weakness: concurrent writes to the same register result in one being lost (the one with the earlier timestamp or lower replica ID).
This is acceptable for some use cases (like "last edit wins" in a profile), but not for others.</p>
<h2>Observed-Remove Set (OR-Set)</h2>
<p>Sets are trickier.
If replica A adds element X and replica B removes X concurrently, should X be in the final set?
The OR-Set uses unique tags to track which adds have been observed by which removes:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ORSet</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Observed-Remove Set (state-based CRDT)."""</span>
    <span class="n">replica_id</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">elements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">any</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>  <span class="c1"># element -&gt; set of unique tags</span>
    <span class="n">tag_counter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="nb">any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Add an element with a unique tag."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tag_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tag_counter</span><span class="si">}</span><span class="s2">"</span>

        <span class="k">if</span> <span class="n">element</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tag</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="nb">any</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Remove an element (removes all observed tags)."""</span>
        <span class="k">if</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">element</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="nb">any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Check if element is in the set."""</span>
        <span class="k">return</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">element</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">"""Get the current set of elements."""</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">tags</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">tags</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">'ORSet'</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Merge another set's state."""</span>
        <span class="c1"># Union of all tags for each element</span>
        <span class="n">all_elements</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">all_elements</span><span class="p">:</span>
            <span class="n">self_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
            <span class="n">other_tags</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
            <span class="n">merged_tags</span> <span class="o">=</span> <span class="n">self_tags</span> <span class="o">|</span> <span class="n">other_tags</span>

            <span class="k">if</span> <span class="n">merged_tags</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_tags</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">'ORSet'</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Create a copy of this set."""</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">ORSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">result</span><span class="o">.</span><span class="n">tag_counter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag_counter</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"ORSet(id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">, value=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">)"</span>
</code></pre></div>
<p>The OR-Set principle: an element is in the set if there exists an add tag that hasn't been removed.
This gives "add-wins" semantics—concurrent add and remove results in the element being present.</p>
<h2>CRDT Replica with Synchronization</h2>
<p>Now let's create replicas that can update their CRDTs and synchronize with each other:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CRDTReplica</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""A replica maintaining CRDT state and syncing with others."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replica_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sync_interval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span> <span class="o">=</span> <span class="n">replica_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sync_interval</span> <span class="o">=</span> <span class="n">sync_interval</span>

        <span class="c1"># Initialize CRDTs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="n">PNCounter</span><span class="p">(</span><span class="n">replica_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register</span> <span class="o">=</span> <span class="n">LWWRegister</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orset</span> <span class="o">=</span> <span class="n">ORSet</span><span class="p">(</span><span class="n">replica_id</span><span class="p">)</span>

        <span class="c1"># Track other replicas for syncing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">other_replicas</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">'CRDTReplica'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Statistics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updates_applied</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">syncs_sent</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Periodically sync with other replicas."""</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sync_interval</span><span class="p">)</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_with_peers</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_peer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replica</span><span class="p">:</span> <span class="s1">'CRDTReplica'</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Register another replica to sync with."""</span>
        <span class="k">if</span> <span class="n">replica</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">other_replicas</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">other_replicas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">sync_with_peers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Send state to all peers."""</span>
        <span class="k">for</span> <span class="n">peer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">other_replicas</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_state_to</span><span class="p">(</span><span class="n">peer</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">send_state_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peer</span><span class="p">:</span> <span class="s1">'CRDTReplica'</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Send our CRDT state to a peer."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">syncs_sent</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Copy our state to send</span>
        <span class="n">counter_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">register_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">set_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Peer receives and merges</span>
        <span class="n">peer</span><span class="o">.</span><span class="n">receive_state</span><span class="p">(</span><span class="n">counter_copy</span><span class="p">,</span> <span class="n">register_copy</span><span class="p">,</span> <span class="n">set_copy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">receive_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">counter</span><span class="p">:</span> <span class="n">PNCounter</span><span class="p">,</span> <span class="n">register</span><span class="p">:</span> <span class="n">LWWRegister</span><span class="p">,</span> 
                     <span class="n">orset</span><span class="p">:</span> <span class="n">ORSet</span><span class="p">,</span> <span class="n">from_replica</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Receive and merge state from another replica."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">register</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">orset</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">: Received state from </span><span class="si">{</span><span class="n">from_replica</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"  Counter: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"  Register: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"  Set: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">local_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Locally increment the counter."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updates_applied</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">: Incremented by </span><span class="si">{</span><span class="n">amount</span><span class="si">}</span><span class="s2"> "</span>
              <span class="sa">f</span><span class="s2">"-&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">local_decrement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Locally decrement the counter."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">decrement</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updates_applied</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">: Decremented by </span><span class="si">{</span><span class="n">amount</span><span class="si">}</span><span class="s2"> "</span>
              <span class="sa">f</span><span class="s2">"-&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">local_set_register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">any</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Locally set the register value."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updates_applied</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">: Set register to '</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">'"</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">local_add_to_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="nb">any</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Locally add element to set."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updates_applied</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">: Added '</span><span class="si">{</span><span class="n">element</span><span class="si">}</span><span class="s2">' to set "</span>
              <span class="sa">f</span><span class="s2">"-&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">local_remove_from_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="nb">any</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Locally remove element from set."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updates_applied</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">: Removed '</span><span class="si">{</span><span class="n">element</span><span class="si">}</span><span class="s2">' from set "</span>
              <span class="sa">f</span><span class="s2">"-&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>
<h2>Simulating Concurrent Updates</h2>
<p>Let's create a simulation where replicas make concurrent updates and eventually converge:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CRDTWorkload</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Generate CRDT operations on a replica."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replica</span><span class="p">:</span> <span class="n">CRDTReplica</span><span class="p">,</span> <span class="n">operations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replica</span> <span class="o">=</span> <span class="n">replica</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operations</span> <span class="o">=</span> <span class="n">operations</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Execute operations with delays."""</span>
        <span class="k">for</span> <span class="n">op_type</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">op_type</span> <span class="o">==</span> <span class="s2">"wait"</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">op_type</span> <span class="o">==</span> <span class="s2">"increment"</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">replica</span><span class="o">.</span><span class="n">local_increment</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">args</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">op_type</span> <span class="o">==</span> <span class="s2">"decrement"</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">replica</span><span class="o">.</span><span class="n">local_decrement</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">args</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">op_type</span> <span class="o">==</span> <span class="s2">"set"</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">replica</span><span class="o">.</span><span class="n">local_set_register</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">op_type</span> <span class="o">==</span> <span class="s2">"add"</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">replica</span><span class="o">.</span><span class="n">local_add_to_set</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">op_type</span> <span class="o">==</span> <span class="s2">"remove"</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">replica</span><span class="o">.</span><span class="n">local_remove_from_set</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Small delay between operations</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">run_basic_simulation</span><span class="p">():</span>
<span class="w">    </span><span class="sd">"""Demonstrate basic CRDT convergence."""</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>

    <span class="c1"># Create three replicas</span>
    <span class="n">replica1</span> <span class="o">=</span> <span class="n">CRDTReplica</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s2">"R1"</span><span class="p">,</span> <span class="n">sync_interval</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="n">replica2</span> <span class="o">=</span> <span class="n">CRDTReplica</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s2">"R2"</span><span class="p">,</span> <span class="n">sync_interval</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="n">replica3</span> <span class="o">=</span> <span class="n">CRDTReplica</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s2">"R3"</span><span class="p">,</span> <span class="n">sync_interval</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>

    <span class="c1"># Connect replicas in a mesh</span>
    <span class="n">replica1</span><span class="o">.</span><span class="n">add_peer</span><span class="p">(</span><span class="n">replica2</span><span class="p">)</span>
    <span class="n">replica1</span><span class="o">.</span><span class="n">add_peer</span><span class="p">(</span><span class="n">replica3</span><span class="p">)</span>
    <span class="n">replica2</span><span class="o">.</span><span class="n">add_peer</span><span class="p">(</span><span class="n">replica1</span><span class="p">)</span>
    <span class="n">replica2</span><span class="o">.</span><span class="n">add_peer</span><span class="p">(</span><span class="n">replica3</span><span class="p">)</span>
    <span class="n">replica3</span><span class="o">.</span><span class="n">add_peer</span><span class="p">(</span><span class="n">replica1</span><span class="p">)</span>
    <span class="n">replica3</span><span class="o">.</span><span class="n">add_peer</span><span class="p">(</span><span class="n">replica2</span><span class="p">)</span>

    <span class="c1"># Replica 1: increment counter</span>
    <span class="n">workload1</span> <span class="o">=</span> <span class="n">CRDTWorkload</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">replica1</span><span class="p">,</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">"increment"</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">"set"</span><span class="p">,</span> <span class="s2">"Alice"</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">"add"</span><span class="p">,</span> <span class="s2">"apple"</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">"add"</span><span class="p">,</span> <span class="s2">"banana"</span><span class="p">),</span>
    <span class="p">])</span>

    <span class="c1"># Replica 2: concurrent operations</span>
    <span class="n">workload2</span> <span class="o">=</span> <span class="n">CRDTWorkload</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">replica2</span><span class="p">,</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">"increment"</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">"set"</span><span class="p">,</span> <span class="s2">"Bob"</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">"add"</span><span class="p">,</span> <span class="s2">"cherry"</span><span class="p">),</span>
    <span class="p">])</span>

    <span class="c1"># Replica 3: more concurrent operations</span>
    <span class="n">workload3</span> <span class="o">=</span> <span class="n">CRDTWorkload</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">replica3</span><span class="p">,</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">"decrement"</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">"set"</span><span class="p">,</span> <span class="s2">"Charlie"</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">"add"</span><span class="p">,</span> <span class="s2">"banana"</span><span class="p">),</span>  <span class="c1"># Concurrent add of same element</span>
        <span class="p">(</span><span class="s2">"remove"</span><span class="p">,</span> <span class="s2">"apple"</span><span class="p">),</span>  <span class="c1"># Concurrent remove</span>
    <span class="p">])</span>

    <span class="c1"># Run simulation</span>
    <span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

    <span class="c1"># Check convergence</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">=== Final States ==="</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"R1: Counter=</span><span class="si">{</span><span class="n">replica1</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">, "</span>
          <span class="sa">f</span><span class="s2">"Register='</span><span class="si">{</span><span class="n">replica1</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">', "</span>
          <span class="sa">f</span><span class="s2">"Set=</span><span class="si">{</span><span class="n">replica1</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"R2: Counter=</span><span class="si">{</span><span class="n">replica2</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">, "</span>
          <span class="sa">f</span><span class="s2">"Register='</span><span class="si">{</span><span class="n">replica2</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">', "</span>
          <span class="sa">f</span><span class="s2">"Set=</span><span class="si">{</span><span class="n">replica2</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"R3: Counter=</span><span class="si">{</span><span class="n">replica3</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">, "</span>
          <span class="sa">f</span><span class="s2">"Register='</span><span class="si">{</span><span class="n">replica3</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">', "</span>
          <span class="sa">f</span><span class="s2">"Set=</span><span class="si">{</span><span class="n">replica3</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="c1"># Verify convergence</span>
    <span class="k">assert</span> <span class="n">replica1</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="n">replica2</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="n">replica3</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">replica1</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">replica2</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">replica3</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">value</span>
    <span class="k">assert</span> <span class="n">replica1</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="n">replica2</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="n">replica3</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">✓ All replicas converged!"</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">run_basic_simulation</span><span class="p">()</span>
</code></pre></div>
<h2>Operation-Based CRDTs</h2>
<p>State-based CRDTs send full state.
Operation-based CRDTs send just the operations.
Let's implement an operation-based counter:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Operation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""An operation on a CRDT."""</span>
    <span class="n">op_type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">replica_id</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">element</span><span class="p">:</span> <span class="nb">any</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">timestamp</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">""</span>


<span class="k">class</span><span class="w"> </span><span class="nc">OpBasedCounter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Operation-based PN-Counter."""</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replica_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span> <span class="o">=</span> <span class="n">replica_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">applied_ops</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># For deduplication</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Operation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Create increment operation."""</span>
        <span class="k">return</span> <span class="n">Operation</span><span class="p">(</span>
            <span class="n">op_type</span><span class="o">=</span><span class="s2">"increment"</span><span class="p">,</span>
            <span class="n">replica_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">decrement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Operation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Create decrement operation."""</span>
        <span class="k">return</span> <span class="n">Operation</span><span class="p">(</span>
            <span class="n">op_type</span><span class="o">=</span><span class="s2">"decrement"</span><span class="p">,</span>
            <span class="n">replica_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="n">Operation</span><span class="p">,</span> <span class="n">op_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Apply an operation if not already applied."""</span>
        <span class="k">if</span> <span class="n">op_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">applied_ops</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># Already applied, skip (idempotence)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">applied_ops</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op_id</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">op_type</span> <span class="o">==</span> <span class="s2">"increment"</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="n">op</span><span class="o">.</span><span class="n">amount</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">op_type</span> <span class="o">==</span> <span class="s2">"decrement"</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-=</span> <span class="n">op</span><span class="o">.</span><span class="n">amount</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"OpCounter(id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">, value=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">)"</span>
</code></pre></div>
<p>Operation-based CRDTs require reliable broadcast (every operation reaches every replica exactly once).
In practice, this means tracking which operations have been delivered and handling duplicates.</p>
<h2>Network Partition Simulation</h2>
<p>One of CRDTs' key benefits is partition tolerance.
Let's simulate a network partition:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">PartitionedCRDTReplica</span><span class="p">(</span><span class="n">CRDTReplica</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""CRDT replica that can be partitioned."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replica_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sync_interval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">replica_id</span><span class="p">,</span> <span class="n">sync_interval</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partitioned_from</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">partition_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replica_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Simulate network partition from another replica."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partitioned_from</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">replica_id</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">: Partitioned from </span><span class="si">{</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">heal_partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replica_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Heal network partition."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partitioned_from</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">replica_id</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">: Healed partition with </span><span class="si">{</span><span class="n">replica_id</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">send_state_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peer</span><span class="p">:</span> <span class="s1">'CRDTReplica'</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Send state only if not partitioned."""</span>
        <span class="k">if</span> <span class="n">peer</span><span class="o">.</span><span class="n">replica_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partitioned_from</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># Network partition, can't send</span>

        <span class="k">await</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">send_state_to</span><span class="p">(</span><span class="n">peer</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">PartitionManager</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Manages network partitions."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replicas</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PartitionedCRDTReplica</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replicas</span> <span class="o">=</span> <span class="n">replicas</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Create and heal partitions."""</span>
        <span class="c1"># Create partition at time 2</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replicas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">partition_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replicas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replica_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replicas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">partition_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replicas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replica_id</span><span class="p">)</span>

        <span class="c1"># Heal partition at time 8</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="mf">6.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replicas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">heal_partition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replicas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replica_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replicas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">heal_partition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replicas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replica_id</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">run_partition_simulation</span><span class="p">():</span>
<span class="w">    </span><span class="sd">"""Demonstrate CRDT behavior during network partition."""</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>

    <span class="c1"># Create two replicas</span>
    <span class="n">replica1</span> <span class="o">=</span> <span class="n">PartitionedCRDTReplica</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s2">"R1"</span><span class="p">,</span> <span class="n">sync_interval</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">replica2</span> <span class="o">=</span> <span class="n">PartitionedCRDTReplica</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s2">"R2"</span><span class="p">,</span> <span class="n">sync_interval</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="n">replica1</span><span class="o">.</span><span class="n">add_peer</span><span class="p">(</span><span class="n">replica2</span><span class="p">)</span>
    <span class="n">replica2</span><span class="o">.</span><span class="n">add_peer</span><span class="p">(</span><span class="n">replica1</span><span class="p">)</span>

    <span class="c1"># Create partition manager</span>
    <span class="n">partition_mgr</span> <span class="o">=</span> <span class="n">PartitionManager</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="p">[</span><span class="n">replica1</span><span class="p">,</span> <span class="n">replica2</span><span class="p">])</span>

    <span class="c1"># Workload: updates during partition</span>
    <span class="n">workload1</span> <span class="o">=</span> <span class="n">CRDTWorkload</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">replica1</span><span class="p">,</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">"wait"</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">"increment"</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">"add"</span><span class="p">,</span> <span class="s2">"item1"</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">"set"</span><span class="p">,</span> <span class="s2">"R1_value"</span><span class="p">),</span>
    <span class="p">])</span>

    <span class="n">workload2</span> <span class="o">=</span> <span class="n">CRDTWorkload</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">replica2</span><span class="p">,</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">"wait"</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">"increment"</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">"add"</span><span class="p">,</span> <span class="s2">"item2"</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">"set"</span><span class="p">,</span> <span class="s2">"R2_value"</span><span class="p">),</span>
    <span class="p">])</span>

    <span class="c1"># Run simulation</span>
    <span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">=== Final State After Partition Heal ==="</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"R1: Counter=</span><span class="si">{</span><span class="n">replica1</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">, "</span>
          <span class="sa">f</span><span class="s2">"Register='</span><span class="si">{</span><span class="n">replica1</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">', "</span>
          <span class="sa">f</span><span class="s2">"Set=</span><span class="si">{</span><span class="n">replica1</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"R2: Counter=</span><span class="si">{</span><span class="n">replica2</span><span class="o">.</span><span class="n">counter</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">, "</span>
          <span class="sa">f</span><span class="s2">"Register='</span><span class="si">{</span><span class="n">replica2</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">', "</span>
          <span class="sa">f</span><span class="s2">"Set=</span><span class="si">{</span><span class="n">replica2</span><span class="o">.</span><span class="n">orset</span><span class="o">.</span><span class="n">value</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">✓ CRDTs converged despite partition!"</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">run_partition_simulation</span><span class="p">()</span>
</code></pre></div>
<h2>Real-World Considerations</h2>
<p>Our implementation demonstrates core concepts, but production CRDT systems need:</p>
<p><strong>Garbage collection</strong>: CRDT metadata grows over time.
Systems need to compact tombstones, merge tags, and remove obsolete version vectors.</p>
<p><strong>Delta-state CRDTs</strong>: Instead of sending full state, send only recent changes (deltas).
This reduces network overhead while maintaining state-based CRDT properties.</p>
<p><strong>Causal delivery</strong>: Operation-based CRDTs require operations to be delivered in causal order (if op1 happened-before op2, deliver op1 first).</p>
<p><strong>Compression</strong>: Vector clocks and OR-Set tags can be compressed.
Riak uses version vectors with server-side compaction.</p>
<p><strong>Semantic awareness</strong>: Generic CRDTs may not match application semantics.
Custom CRDTs can provide better behavior (e.g., shopping cart CRDT that merges intelligently).</p>
<p><strong>Performance</strong>: State-based CRDTs can have large state; operation-based CRDTs require careful broadcast protocols.
Hybrid approaches exist.</p>
<h2>CRDT Types Comparison</h2>
<table>
<thead>
<tr>
<th>CRDT</th>
<th>Operations</th>
<th>Use Case</th>
<th>Metadata Overhead</th>
</tr>
</thead>
<tbody>
<tr>
<td>G-Counter</td>
<td>Increment</td>
<td>Metrics, likes</td>
<td>O(replicas)</td>
</tr>
<tr>
<td>PN-Counter</td>
<td>Inc/Dec</td>
<td>Distributed counters</td>
<td>O(replicas)</td>
</tr>
<tr>
<td>LWW-Register</td>
<td>Set</td>
<td>Profile fields</td>
<td>O(1)</td>
</tr>
<tr>
<td>OR-Set</td>
<td>Add/Remove</td>
<td>Shopping cart</td>
<td>O(elements × adds)</td>
</tr>
<tr>
<td>2P-Set</td>
<td>Add/Remove (no re-add)</td>
<td>Set semantics</td>
<td>O(elements)</td>
</tr>
<tr>
<td>RGA</td>
<td>Insert/Delete</td>
<td>Text editing</td>
<td>O(characters)</td>
</tr>
<tr>
<td>LSeq</td>
<td>Insert/Delete</td>
<td>Collaborative text</td>
<td>O(log n)</td>
</tr>
</tbody>
</table>
<h2>Conclusion</h2>
<p>CRDTs achieve strong eventual consistency without coordination.
The key principles are:</p>
<ol>
<li><strong>Commutativity</strong>: Operations can be applied in any order</li>
<li><strong>Associativity</strong>: Grouping doesn't matter</li>
<li><strong>Idempotence</strong>: Applying the same operation multiple times has the same effect as once</li>
</ol>
<p>These properties guarantee that replicas receiving the same updates converge to the same state, regardless of network delays, partitions, or message reordering.</p>
<p>CRDTs trade coordination for metadata.
Instead of coordinating during updates (locks, consensus), we carry extra information (version vectors, unique tags) and use mathematical merge rules.
This makes CRDTs perfect for:</p>
<ul>
<li><strong>Collaborative editing</strong>: Google Docs, Figma</li>
<li><strong>Offline-first apps</strong>: Mobile apps that sync when connected</li>
<li><strong>Geo-distributed databases</strong>: Riak, Redis</li>
<li><strong>Edge computing</strong>: Low-latency updates without cross-datacenter coordination</li>
</ul>
<p>The simulation approach lets us experiment with concurrent updates, network partitions, and convergence—making CRDT behavior concrete before tackling production implementations.</p>
</main>
<footer>
<div class="row">
<div class="col-3 left">
	  ⇐ <a href="../worksteal/">Work-Stealing Scheduler</a>
</div>
<div class="col-6 center">
<a href="../"></a>
	  © 2025
	  <a href="../#acknowledgments">the authors</a>
</div>
<div class="col-3 right">
<a href="../torrent/">BitTorrent</a> ⇒
	</div>
</div>
</footer>
</body>
</html>