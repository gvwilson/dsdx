<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Work-Stealing Scheduler</title>
<link href="../static/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="../static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../static/page.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav>
<a href="../">Home</a>
      ·
      <span class="dropdown">
<a href="#">Lessons</a>
<span class="dropdown-content" id="nav-lessons">
<a href="../intro/">Introduction</a>
<a href="../oauth/">OAuth</a>
<a href="../msgque/">A Message Queue</a>
<a href="../distlock/">Distributed Locks</a>
<a href="../eventual/">Eventually Consistent Key-Value Store</a>
<a href="../saga/">The Saga Pattern</a>
<a href="../mapreduce/">MapReduce</a>
<a href="../worksteal/">Work-Stealing Scheduler</a>
<a href="../crdt/">Conflict-Free Replicated Data Types</a>
<a href="../torrent/">BitTorrent</a>
<a href="../finale/">Conclusion</a>
</span>
</span>
      ·
      <span class="dropdown">
<a href="#">Appendices</a>
<span class="dropdown-content" id="nav-appendices">
<a href="../license/">License</a>
<a href="../conduct/">Code of Conduct</a>
<a href="../contributing/">Contributing</a>
<a href="../bibliography/">Bibliography</a>
<a href="../glossary/">Glossary</a>
</span>
</span>
</nav>
<main>
<h1>Work-Stealing Scheduler</h1>
<p>Modern programs need to efficiently utilize multiple CPU cores to achieve high performance.
When you have hundreds or thousands of tasks to execute and a handful of CPU cores,
how do you distribute the work?
A naive approach would use a central queue: workers pull tasks from one end,
and new tasks are added to the other.
But this creates a bottleneck—every worker must compete for access to the shared queue.</p>
<p>Work-stealing schedulers solve this problem through decentralization.
Each worker maintains its own local deque (double-ended queue) of tasks.
Workers execute tasks from one end of their own deque,
but when a worker runs out of work
it can "steal" tasks from the other end of another worker's deque.
This design minimizes contention—workers mostly operate on their own queues,
only interacting when load balancing is needed.</p>
<p>This pattern appears throughout high-performance computing:
<a href="https://golang.org/s/go11sched">Go's runtime scheduler</a> uses work-stealing to distribute goroutines across threads,
<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">Java's Fork/Join framework</a> enables parallel divide-and-conquer algorithms,
and <a href="https://tokio.rs/blog/2019-10-scheduler">Tokio</a> (Rust's async runtime) schedules futures across worker threads.
Understanding work-stealing is essential for writing efficient parallel programs.</p>
<h2>The Work-Stealing Pattern</h2>
<p>In a work-stealing system, we have:</p>
<ol>
<li><strong>Workers</strong>: Each worker has a local deque of tasks</li>
<li><strong>Tasks</strong>: Units of work that can be executed independently</li>
<li><strong>Local execution</strong>: Workers pop tasks from the "private" end of their deque</li>
<li><strong>Stealing</strong>: Idle workers steal tasks from the "public" end of other workers' deques</li>
<li><strong>Task spawning</strong>: Running tasks can create new child tasks</li>
</ol>
<p>The key insight is asymmetry: the owning worker operates on one end (the "bottom") while thieves steal from the other end (the "top").
This reduces contention because the owner and thieves usually don't compete for the same task.</p>
<h2>Our Implementation</h2>
<p>We'll build a work-stealing scheduler using asimpy.
Our simulation will show how tasks are distributed, how stealing balances load, and how nested task creation (a task spawning child tasks) works naturally.</p>
<p>Let's start with the task representation:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">asimpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Task</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""A unit of work to be executed."""</span>
    <span class="n">task_id</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">work_duration</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">parent_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># For nested tasks</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"Task(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">task_id</span><span class="si">}</span><span class="s2">)"</span>
</code></pre></div>
<p>Each task has an ID, a duration (simulating CPU-bound work), and optionally a parent task ID for tracking task dependencies.</p>
<h2>Worker Deques</h2>
<p>Each worker maintains a deque.
In our simulation, we'll use a simple list-based deque:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">WorkerDeque</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Double-ended queue for tasks with stealing support."""</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Task</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">push_bottom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">:</span> <span class="n">Task</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Owner pushes task to bottom (private end)."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pop_bottom</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Task</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">"""Owner pops task from bottom."""</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">steal_top</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Task</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">"""Thief steals task from top (public end)."""</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Check if deque is empty."""</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Return number of tasks."""</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">)</span>
</code></pre></div>
<p>In production systems, this would use atomic operations and careful memory ordering to avoid locks.
Our simulation focuses on the algorithmic pattern rather than low-level synchronization.</p>
<h2>Worker Implementation</h2>
<p>A worker executes tasks from its local deque and steals when idle:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Worker</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Worker that executes tasks with work-stealing."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">:</span> <span class="s1">'WorkStealingScheduler'</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span> <span class="o">=</span> <span class="n">worker_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span> <span class="o">=</span> <span class="n">scheduler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deque</span> <span class="o">=</span> <span class="n">WorkerDeque</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks_executed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks_stolen</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_task</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Task</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Main worker loop: execute local tasks or steal."""</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Try to get a task from local deque</span>
            <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deque</span><span class="o">.</span><span class="n">pop_bottom</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">task</span><span class="p">:</span>
                <span class="c1"># Execute local task</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_task</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No local work, try stealing</span>
                <span class="n">stolen</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">try_steal</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">stolen</span><span class="p">:</span>
                    <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute_task</span><span class="p">(</span><span class="n">stolen</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># No work available anywhere, wait a bit</span>
                    <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">execute_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">:</span> <span class="n">Task</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Execute a task."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_task</span> <span class="o">=</span> <span class="n">task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks_executed</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] Worker </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="si">}</span><span class="s2">: "</span>
              <span class="sa">f</span><span class="s2">"Executing </span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">task_id</span><span class="si">}</span><span class="s2"> (queue size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">deque</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>

        <span class="c1"># Simulate work</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">work_duration</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] Worker </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="si">}</span><span class="s2">: "</span>
              <span class="sa">f</span><span class="s2">"Completed </span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">task_id</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">current_task</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">try_steal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Task</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">"""Try to steal a task from another worker."""</span>
        <span class="c1"># Random victim selection</span>
        <span class="n">victims</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">workers</span> <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">victims</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Shuffle to avoid patterns</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">victims</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">victim</span> <span class="ow">in</span> <span class="n">victims</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">victim</span><span class="o">.</span><span class="n">deque</span><span class="o">.</span><span class="n">steal_top</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">task</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tasks_stolen</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] Worker </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="si">}</span><span class="s2">: "</span>
                      <span class="sa">f</span><span class="s2">"Stole </span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">task_id</span><span class="si">}</span><span class="s2"> from Worker </span><span class="si">{</span><span class="n">victim</span><span class="o">.</span><span class="n">worker_id</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">task</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">spawn_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">:</span> <span class="n">Task</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Spawn a new task (called by executing task)."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deque</span><span class="o">.</span><span class="n">push_bottom</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] Worker </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="si">}</span><span class="s2">: "</span>
              <span class="sa">f</span><span class="s2">"Spawned </span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">task_id</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>
<p>The worker continuously tries to execute tasks.
If its local deque is empty, it attempts to steal from other workers.
If stealing fails, it waits briefly before trying again.</p>
<h2>Scheduler</h2>
<p>The scheduler coordinates workers and provides task submission:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">WorkStealingScheduler</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Scheduler that coordinates work-stealing workers."""</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">num_workers</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_workers</span> <span class="o">=</span> <span class="n">num_workers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Worker</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Create workers</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_workers</span><span class="p">):</span>
            <span class="n">worker</span> <span class="o">=</span> <span class="n">Worker</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">submit_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work_duration</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
                   <span class="n">parent_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Task</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Submit a task to a random worker."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span>
            <span class="n">task_id</span><span class="o">=</span><span class="sa">f</span><span class="s2">"T</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">task_counter</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span>
            <span class="n">work_duration</span><span class="o">=</span><span class="n">work_duration</span><span class="p">,</span>
            <span class="n">parent_id</span><span class="o">=</span><span class="n">parent_id</span>
        <span class="p">)</span>

        <span class="c1"># Assign to random worker (could use other strategies)</span>
        <span class="n">worker</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="p">)</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">deque</span><span class="o">.</span><span class="n">push_bottom</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] Submitted </span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">task_id</span><span class="si">}</span><span class="s2"> "</span>
              <span class="sa">f</span><span class="s2">"to Worker </span><span class="si">{</span><span class="n">worker</span><span class="o">.</span><span class="n">worker_id</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">task</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Get scheduler statistics."""</span>
        <span class="n">total_executed</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">tasks_executed</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="p">)</span>
        <span class="n">total_stolen</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">tasks_stolen</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">=== Statistics ==="</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Total tasks executed: </span><span class="si">{</span><span class="n">total_executed</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Total tasks stolen: </span><span class="si">{</span><span class="n">total_stolen</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Steal rate: </span><span class="si">{</span><span class="mi">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">total_stolen</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="n">total_executed</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%"</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">worker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Worker </span><span class="si">{</span><span class="n">worker</span><span class="o">.</span><span class="n">worker_id</span><span class="si">}</span><span class="s2">: "</span>
                  <span class="sa">f</span><span class="s2">"executed=</span><span class="si">{</span><span class="n">worker</span><span class="o">.</span><span class="n">tasks_executed</span><span class="si">}</span><span class="s2">, "</span>
                  <span class="sa">f</span><span class="s2">"stolen=</span><span class="si">{</span><span class="n">worker</span><span class="o">.</span><span class="n">tasks_stolen</span><span class="si">}</span><span class="s2">, "</span>
                  <span class="sa">f</span><span class="s2">"queue=</span><span class="si">{</span><span class="n">worker</span><span class="o">.</span><span class="n">deque</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>
<h2>Basic Simulation</h2>
<p>Let's create a simple simulation with load imbalance to see stealing in action:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">run_basic_simulation</span><span class="p">():</span>
<span class="w">    </span><span class="sd">"""Basic work-stealing simulation."""</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>

    <span class="c1"># Create scheduler with 3 workers</span>
    <span class="n">scheduler</span> <span class="o">=</span> <span class="n">WorkStealingScheduler</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Submit tasks with varying durations</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">scheduler</span><span class="o">.</span><span class="n">submit_task</span><span class="p">(</span><span class="n">work_duration</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">))</span>

    <span class="c1"># Run simulation</span>
    <span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

    <span class="c1"># Print statistics</span>
    <span class="n">scheduler</span><span class="o">.</span><span class="n">get_statistics</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">run_basic_simulation</span><span class="p">()</span>
</code></pre></div>
<p>When you run this, you'll see workers executing tasks and stealing from each other when they run out of local work.
The steal rate shows how much load balancing occurred.</p>
<h2>Nested Task Spawning</h2>
<p>One powerful feature of work-stealing is handling nested parallelism—tasks that create subtasks.
This is the foundation of parallel divide-and-conquer algorithms:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TaskGenerator</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Generates tasks including ones that spawn subtasks."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">:</span> <span class="n">WorkStealingScheduler</span><span class="p">,</span> 
             <span class="n">num_initial_tasks</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span> <span class="o">=</span> <span class="n">scheduler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_initial_tasks</span> <span class="o">=</span> <span class="n">num_initial_tasks</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Generate initial tasks."""</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_initial_tasks</span><span class="p">):</span>
            <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">submit_task</span><span class="p">(</span>
                <span class="n">work_duration</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">WorkerWithSpawning</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Worker that can spawn child tasks during execution."""</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">execute_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">:</span> <span class="n">Task</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Execute task and possibly spawn children."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_task</span> <span class="o">=</span> <span class="n">task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks_executed</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] Worker </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="si">}</span><span class="s2">: "</span>
              <span class="sa">f</span><span class="s2">"Executing </span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">task_id</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

        <span class="c1"># Do half the work</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">work_duration</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Randomly spawn child tasks (simulating divide-and-conquer)</span>
        <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.3</span><span class="p">:</span>  <span class="c1"># 30% chance</span>
            <span class="n">num_children</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_children</span><span class="p">):</span>
                <span class="n">child</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span>
                    <span class="n">task_id</span><span class="o">=</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">task_id</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span>
                    <span class="n">work_duration</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
                    <span class="n">parent_id</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">task_id</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spawn_task</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

        <span class="c1"># Finish the work</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">work_duration</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] Worker </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="si">}</span><span class="s2">: "</span>
              <span class="sa">f</span><span class="s2">"Completed </span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">task_id</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">current_task</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SchedulerWithSpawning</span><span class="p">(</span><span class="n">WorkStealingScheduler</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Scheduler using workers that can spawn tasks."""</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">num_workers</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_workers</span> <span class="o">=</span> <span class="n">num_workers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">WorkerWithSpawning</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Create workers with spawning capability</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_workers</span><span class="p">):</span>
            <span class="n">worker</span> <span class="o">=</span> <span class="n">WorkerWithSpawning</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">run_spawning_simulation</span><span class="p">():</span>
<span class="w">    </span><span class="sd">"""Demonstrate nested task spawning."""</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>

    <span class="c1"># Create scheduler with spawning workers</span>
    <span class="n">scheduler</span> <span class="o">=</span> <span class="n">SchedulerWithSpawning</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Generate initial tasks</span>
    <span class="n">generator</span> <span class="o">=</span> <span class="n">TaskGenerator</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">,</span> <span class="n">num_initial_tasks</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="c1"># Run simulation</span>
    <span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>

    <span class="c1"># Print statistics</span>
    <span class="n">scheduler</span><span class="o">.</span><span class="n">get_statistics</span><span class="p">()</span>
</code></pre></div>
<p>This simulation shows how tasks can spawn children, which are added to the local deque and may be stolen by other workers.
This naturally balances load even with irregular task creation patterns.</p>
<h2>Load Balancing Strategies</h2>
<p>Different victim selection strategies affect performance:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">AdaptiveWorker</span><span class="p">(</span><span class="n">Worker</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Worker with adaptive victim selection."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">:</span> <span class="s1">'WorkStealingScheduler'</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">worker_id</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">steal_attempts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed_steals</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">try_steal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Task</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">"""Try to steal with adaptive victim selection."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">steal_attempts</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Try workers with largest queues first</span>
        <span class="n">victims</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">workers</span> <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">victims</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">deque</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">victim</span> <span class="ow">in</span> <span class="n">victims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">victim</span><span class="o">.</span><span class="n">deque</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">victim</span><span class="o">.</span><span class="n">deque</span><span class="o">.</span><span class="n">steal_top</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">task</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tasks_stolen</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] Worker </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">worker_id</span><span class="si">}</span><span class="s2">: "</span>
                          <span class="sa">f</span><span class="s2">"Stole </span><span class="si">{</span><span class="n">task</span><span class="o">.</span><span class="n">task_id</span><span class="si">}</span><span class="s2"> from Worker </span><span class="si">{</span><span class="n">victim</span><span class="o">.</span><span class="n">worker_id</span><span class="si">}</span><span class="s2"> "</span>
                          <span class="sa">f</span><span class="s2">"(victim queue: </span><span class="si">{</span><span class="n">victim</span><span class="o">.</span><span class="n">deque</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">task</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">failed_steals</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AdaptiveScheduler</span><span class="p">(</span><span class="n">WorkStealingScheduler</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Scheduler with adaptive workers."""</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">num_workers</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_workers</span> <span class="o">=</span> <span class="n">num_workers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">AdaptiveWorker</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_workers</span><span class="p">):</span>
            <span class="n">worker</span> <span class="o">=</span> <span class="n">AdaptiveWorker</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">run_adaptive_simulation</span><span class="p">():</span>
<span class="w">    </span><span class="sd">"""Demonstrate adaptive stealing strategy."""</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>

    <span class="n">scheduler</span> <span class="o">=</span> <span class="n">AdaptiveScheduler</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Create imbalanced initial load</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
        <span class="c1"># Give most tasks to worker 0</span>
        <span class="n">worker_idx</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">12</span> <span class="k">else</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">scheduler</span><span class="o">.</span><span class="n">workers</span><span class="p">[</span><span class="n">worker_idx</span><span class="p">]</span><span class="o">.</span><span class="n">deque</span><span class="o">.</span><span class="n">push_bottom</span><span class="p">(</span>
            <span class="n">Task</span><span class="p">(</span><span class="sa">f</span><span class="s2">"T</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
    <span class="n">scheduler</span><span class="o">.</span><span class="n">get_statistics</span><span class="p">()</span>
</code></pre></div>
<p>The adaptive strategy targets victims with the most work, leading to faster load balancing.</p>
<h2>Task Granularity and Performance</h2>
<p>Task granularity—how much work each task does—significantly affects performance.
Too fine-grained, and scheduling overhead dominates; too coarse-grained, and load imbalance reduces parallelism:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">PerformanceAnalyzer</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Analyzes scheduler performance with different granularities."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">:</span> <span class="n">WorkStealingScheduler</span><span class="p">,</span> 
             <span class="n">total_work</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">task_granularity</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span> <span class="o">=</span> <span class="n">scheduler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_work</span> <span class="o">=</span> <span class="n">total_work</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_granularity</span> <span class="o">=</span> <span class="n">task_granularity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Submit tasks and measure completion time."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">now</span>

        <span class="n">num_tasks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_work</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_granularity</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="se">\n</span><span class="s2">[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] Starting: </span><span class="si">{</span><span class="n">num_tasks</span><span class="si">}</span><span class="s2"> tasks "</span>
              <span class="sa">f</span><span class="s2">"of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">task_granularity</span><span class="si">}</span><span class="s2">s each"</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_tasks</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">submit_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_granularity</span><span class="p">)</span>

        <span class="c1"># Wait for all workers to become idle</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

            <span class="n">all_idle</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">w</span><span class="o">.</span><span class="n">deque</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span> <span class="ow">and</span> <span class="n">w</span><span class="o">.</span><span class="n">current_task</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">workers</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">all_idle</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">now</span>
                <span class="k">break</span>

        <span class="n">elapsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span>
        <span class="n">speedup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_work</span> <span class="o">/</span> <span class="n">elapsed</span>
        <span class="n">efficiency</span> <span class="o">=</span> <span class="n">speedup</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">num_workers</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="se">\n</span><span class="s2">=== Performance Analysis ==="</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Granularity: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">task_granularity</span><span class="si">}</span><span class="s2">s"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Total work: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">total_work</span><span class="si">}</span><span class="s2">s"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Wall time: </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Speedup: </span><span class="si">{</span><span class="n">speedup</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">x"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Efficiency: </span><span class="si">{</span><span class="n">efficiency</span><span class="si">:</span><span class="s2">.1%</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">run_granularity_experiment</span><span class="p">():</span>
<span class="w">    </span><span class="sd">"""Experiment with different task granularities."""</span>
    <span class="k">for</span> <span class="n">granularity</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="se">\n</span><span class="si">{</span><span class="s1">'='</span><span class="o">*</span><span class="mi">60</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Testing granularity: </span><span class="si">{</span><span class="n">granularity</span><span class="si">}</span><span class="s2">s"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'='</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span>

        <span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
        <span class="n">scheduler</span> <span class="o">=</span> <span class="n">WorkStealingScheduler</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">analyzer</span> <span class="o">=</span> <span class="n">PerformanceAnalyzer</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">,</span> 
            <span class="n">total_work</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span> 
            <span class="n">task_granularity</span><span class="o">=</span><span class="n">granularity</span>
        <span class="p">)</span>

        <span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
        <span class="n">scheduler</span><span class="o">.</span><span class="n">get_statistics</span><span class="p">()</span>
</code></pre></div>
<p>This experiment shows how granularity affects speedup and efficiency.
Fine-grained tasks enable better load balancing but increase overhead.</p>
<h2>Real-World Considerations</h2>
<p>Our implementation demonstrates core concepts, but production work-stealing schedulers need:</p>
<ul>
<li>
<p><strong>Lock-free deques</strong>: Use atomic compare-and-swap operations instead of locks.
The <a href="https://www.dre.vanderbilt.edu/~schmidt/PDF/work-stealing-dequeue.pdf">Chase-Lev deque</a> is a popular choice.</p>
</li>
<li>
<p><strong>Bounded stealing attempts</strong>: Prevent livelock by limiting how long a worker searches for victims.</p>
</li>
<li>
<p><strong>NUMA awareness</strong>: On multi-socket systems, prefer stealing from nearby workers to maintain cache locality.</p>
</li>
<li>
<p><strong>Priority queues</strong>: Some tasks are more important than others and should execute first.</p>
</li>
<li>
<p><strong>Backoff strategies</strong>: Idle workers should back off exponentially rather than spinning continuously.</p>
</li>
<li>
<p><strong>Work affinity</strong>: Tasks that share data should execute on the same worker when possible.</p>
</li>
<li>
<p><strong>Termination detection</strong>: Determining when all work is complete in a distributed system is non-trivial.</p>
</li>
</ul>
<h2>Conclusion</h2>
<p>Work-stealing schedulers achieve efficient load balancing through decentralization.
Each worker operates mostly independently, reducing contention.
Stealing provides dynamic load balancing without central coordination.
The key principles are:</p>
<ol>
<li><strong>Local deques</strong> minimize contention between workers</li>
<li><strong>Asymmetric access</strong> (bottom vs. top) reduces conflicts</li>
<li><strong>Random victim selection</strong> prevents pathological patterns</li>
<li><strong>Task spawning</strong> naturally supports divide-and-conquer algorithms</li>
<li><strong>Granularity</strong> must balance overhead against load balancing</li>
</ol>
</main>
<footer>
<div class="row">
<div class="col-3 left">
	  ⇐ <a href="../mapreduce/">MapReduce</a>
</div>
<div class="col-6 center">
<a href="../"></a>
	  © 2025
	  <a href="../#acknowledgments">the authors</a>
</div>
<div class="col-3 right">
<a href="../crdt/">Conflict-Free Replicated Data Types</a> ⇒
	</div>
</div>
</footer>
</body>
</html>