<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Building TCP on UDP</title>
<link href="../static/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="../static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../static/page.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav>
<a href="../">Home</a>
      ·
      <span class="dropdown">
<a href="#">Lessons</a>
<span class="dropdown-content" id="nav-lessons">
<a href="../intro/">Introduction</a>
<a href="../msgque/">A Message Queue</a>
<a href="../worksteal/">Work-Stealing Scheduler</a>
<a href="../tracing/">Distributed Tracing</a>
<a href="../crdt/">Conflict-Free Replicated Data Types</a>
<a href="../mapreduce/">MapReduce</a>
<a href="../oauth/">OAuth</a>
<a href="../distlock/">Distributed Locks</a>
<a href="../torrent/">BitTorrent</a>
<a href="../eventual/">Eventually Consistent Key-Value Store</a>
<a href="../saga/">The Saga Pattern</a>
<a href="../tcp/">TCP</a>
<a href="../finale/">Conclusion</a>
</span>
</span>
      ·
      <span class="dropdown">
<a href="#">Appendices</a>
<span class="dropdown-content" id="nav-appendices">
<a href="../license/">License</a>
<a href="../conduct/">Code of Conduct</a>
<a href="../contributing/">Contributing</a>
<a href="../bibliography/">Bibliography</a>
<a href="../glossary/">Glossary</a>
</span>
</span>
</nav>
<main>
<h1>Building TCP on UDP</h1>
<p>When you open a website, stream a video, or send an email,
you're almost certainly using TCP (Transmission Control Protocol).
TCP provides reliable, ordered delivery of data over the internet,
handling packet loss, reordering, and congestion automatically.
But TCP itself runs on top of UDP,
which only provides best-effort, unordered packet delivery with no guarantees.</p>
<p>Building a simplified TCP on top of UDP demonstrates
the core mechanisms that make reliable communication possible over unreliable networks:
sequence numbers for ordering,
acknowledgments for reliability,
retransmission timers for handling loss,
and flow control for preventing overwhelm.
These same principles appear throughout distributed systems:
message queues use acknowledgments,
databases use write-ahead logs with sequence numbers,
and streaming protocols use sliding windows.</p>
<p>This pattern is fundamental to understanding how networks work.
Google's QUIC protocol reimplements TCP-like reliability over UDP to enable faster connection establishment.
Reliable UDP libraries like ENet power multiplayer games.</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>UDP</th>
<th>Our TCP</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reliability</td>
<td>None</td>
<td>Guaranteed delivery</td>
</tr>
<tr>
<td>Ordering</td>
<td>None</td>
<td>In-order delivery</td>
</tr>
<tr>
<td>Overhead</td>
<td>Minimal</td>
<td>Header + ACKs + retransmissions</td>
</tr>
<tr>
<td>Latency</td>
<td>Low</td>
<td>Higher (due to ACKs and retransmits)</td>
</tr>
<tr>
<td>Throughput</td>
<td>High</td>
<td>Lower (due to window limits)</td>
</tr>
<tr>
<td>Use Cases</td>
<td>Live video, gaming, DNS</td>
<td>File transfer, web, email</td>
</tr>
</tbody>
</table>
<h2>The TCP Guarantee</h2>
<p>TCP provides a reliable byte stream abstraction over unreliable packet delivery:</p>
<ol>
<li><strong>Reliable delivery</strong>: All data arrives or an error is reported</li>
<li><strong>Ordered delivery</strong>: Data arrives in the order sent</li>
<li><strong>Flow control</strong>: Receiver controls sender rate to prevent overflow</li>
<li><strong>Congestion control</strong>: Sender adapts to network capacity</li>
</ol>
<p>UDP, in contrast, provides none of these guarantees:
packets can be lost, duplicated, reordered, or corrupted.
Our implementation will add reliability and ordering on top of UDP's unreliable datagram service.</p>
<h2>Core Mechanisms</h2>
<p>TCP uses several key mechanisms:</p>
<ul>
<li>
<p><strong>Sequence Numbers</strong>: Each byte has a sequence number.
    Receivers use these to detect missing data and reorder packets.</p>
</li>
<li>
<p><strong>Acknowledgments (ACKs)</strong>: Receivers send ACKs indicating what data they've received.
    Senders use ACKs to know what to retransmit.</p>
</li>
<li>
<p><strong>Retransmission</strong>: If an ACK doesn't arrive within a timeout, the sender retransmits the data.</p>
</li>
<li>
<p><strong>Sliding Window</strong>: Sender can have multiple unacknowledged packets in flight
    to maintain throughput despite round-trip latency.</p>
</li>
<li>
<p><strong>Cumulative ACKs</strong>: ACKs indicate, "I've received everything up to sequence number X,"
    simplifying acknowledgment logic.</p>
</li>
</ul>
<h2>Implementation Overview</h2>
<p>Our TCP-over-UDP implementation consists of:</p>
<ol>
<li><code>tcp_types.py</code>: Core data structures (Packet, SegmentBuffer, ReceiveBuffer)</li>
<li><code>unreliable_network.py</code>: Simulates packet loss, reordering, duplication</li>
<li><code>tcp_connection.py</code>: TCP connection with reliability mechanisms</li>
<li><code>tcp_applications.py</code>: Client and server applications</li>
<li><code>example_basic_tcp.py</code>: Basic reliable transfer demonstration</li>
<li><code>example_loss_recovery.py</code>: High packet loss scenario</li>
</ol>
<p>Let's examine each component.</p>
<h2>Data Structures</h2>
<p>The core types represent TCP segments and connection state:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">PacketType</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Types of TCP packets."""</span>
    <span class="n">SYN</span> <span class="o">=</span> <span class="s2">"SYN"</span>          <span class="c1"># Synchronize (connection establishment)</span>
    <span class="n">SYN_ACK</span> <span class="o">=</span> <span class="s2">"SYN_ACK"</span>  <span class="c1"># Synchronize-Acknowledge</span>
    <span class="n">ACK</span> <span class="o">=</span> <span class="s2">"ACK"</span>          <span class="c1"># Acknowledge</span>
    <span class="n">DATA</span> <span class="o">=</span> <span class="s2">"DATA"</span>        <span class="c1"># Data packet</span>
    <span class="n">FIN</span> <span class="o">=</span> <span class="s2">"FIN"</span>          <span class="c1"># Finish (connection teardown)</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Packet</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""A network packet (simulating IP + TCP)."""</span>
    <span class="n">src_addr</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">dst_addr</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">src_port</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">dst_port</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">seq_num</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">ack_num</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">packet_type</span><span class="p">:</span> <span class="n">PacketType</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">""</span>
    <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">65535</span>
</code></pre></div>
<p>The <code>Packet</code> structure mirrors a real TCP/IP packet header with source and destination addressing,
sequence and acknowledgment numbers,
packet type,
and payload data.</p>
<h2>Unreliable Network Layer</h2>
<p>Before building TCP, we need to simulate UDP's unreliable delivery:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">UnreliableNetwork</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Simulates unreliable packet delivery (like UDP)."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loss_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> 
             <span class="n">reorder_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
             <span class="n">duplicate_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.02</span><span class="p">,</span>
             <span class="n">delay_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss_rate</span> <span class="o">=</span> <span class="n">loss_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reorder_rate</span> <span class="o">=</span> <span class="n">reorder_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_rate</span> <span class="o">=</span> <span class="n">duplicate_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delay_range</span> <span class="o">=</span> <span class="n">delay_range</span>

        <span class="c1"># Network endpoints (address:port -&gt; queue)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Queue</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">send_packet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">packet</span><span class="p">:</span> <span class="n">Packet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Send packet with simulated unreliability."""</span>
        <span class="c1"># Simulate packet loss</span>
        <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_rate</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] Network: LOST </span><span class="si">{</span><span class="n">packet</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Simulate packet duplication</span>
        <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">duplicate_rate</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deliver_packet</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>

        <span class="c1"># Deliver the packet</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deliver_packet</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div>
<p>This simulates the way packets in real networks can be lost, delayed, reordered, or duplicated.
The network maintains a registry of endpoints and routes packets accordingly.</p>
<h2>TCP Connection</h2>
<p>The TCP connection implements reliability over the unreliable network:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TCPConnection</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""TCP connection with reliability over unreliable network."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">local_addr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">local_port</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
             <span class="n">network</span><span class="p">:</span> <span class="n">UnreliableNetwork</span><span class="p">,</span>
             <span class="n">window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
             <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_addr</span> <span class="o">=</span> <span class="n">local_addr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_port</span> <span class="o">=</span> <span class="n">local_port</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">=</span> <span class="n">window_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rto</span> <span class="o">=</span> <span class="n">timeout</span>

        <span class="c1"># Sequence numbers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_seq</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">9999</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recv_seq</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Send buffer for unacknowledged segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_buffer</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SegmentBuffer</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Receive buffer for out-of-order segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recv_buffer</span> <span class="o">=</span> <span class="n">ReceiveBuffer</span><span class="p">()</span>
</code></pre></div>
<p>The connection maintains send and receive buffers.
The send buffer holds unacknowledged segments for potential retransmission.
The receive buffer handles out-of-order delivery by holding segments until gaps are filled.</p>
<h2>Three-Way Handshake</h2>
<p>TCP connection establishment uses three packets to synchronize state:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remote_addr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">remote_port</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Initiate TCP connection (3-way handshake)."""</span>
    <span class="c1"># Send SYN</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">ConnectionState</span><span class="o">.</span><span class="n">SYN_SENT</span>
    <span class="n">syn</span> <span class="o">=</span> <span class="n">Packet</span><span class="p">(</span>
        <span class="n">src_addr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">local_addr</span><span class="p">,</span>
        <span class="n">dst_addr</span><span class="o">=</span><span class="n">remote_addr</span><span class="p">,</span>
        <span class="n">src_port</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">local_port</span><span class="p">,</span>
        <span class="n">dst_port</span><span class="o">=</span><span class="n">remote_port</span><span class="p">,</span>
        <span class="n">seq_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">send_seq</span><span class="p">,</span>
        <span class="n">ack_num</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">packet_type</span><span class="o">=</span><span class="n">PacketType</span><span class="o">.</span><span class="n">SYN</span>
    <span class="p">)</span>

    <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">send_packet</span><span class="p">(</span><span class="n">syn</span><span class="p">)</span>

    <span class="c1"># Wait for SYN-ACK</span>
    <span class="c1"># ... (timing logic)</span>

    <span class="c1"># Send final ACK</span>
    <span class="c1"># Connection established</span>
</code></pre></div>
<p>The handshake sequence is:</p>
<ol>
<li>Client → Server: SYN (seq=x)</li>
<li>Server → Client: SYN-ACK (seq=y, ack=x+1)</li>
<li>Client → Server: ACK (ack=y+1)</li>
</ol>
<p>This synchronizes sequence numbers and establishes bidirectional communication.</p>
<h2>Sliding Window Protocol</h2>
<p>The sliding window allows multiple packets in flight:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Send data reliably using TCP."""</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mtu</span><span class="p">]</span>

        <span class="c1"># Wait if send window is full</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">send_buffer</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

        <span class="c1"># Create and send segment</span>
        <span class="n">segment</span> <span class="o">=</span> <span class="n">Packet</span><span class="p">(</span>
            <span class="n">src_addr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">local_addr</span><span class="p">,</span>
            <span class="n">dst_addr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">remote_addr</span><span class="p">,</span>
            <span class="n">seq_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">next_seq_num</span><span class="p">,</span>
            <span class="n">packet_type</span><span class="o">=</span><span class="n">PacketType</span><span class="o">.</span><span class="n">DATA</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">chunk</span>
        <span class="p">)</span>

        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">send_packet</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>

        <span class="c1"># Add to send buffer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SegmentBuffer</span><span class="p">(</span>
            <span class="n">seq_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">next_seq_num</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">chunk</span><span class="p">,</span>
            <span class="n">sent_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span>
        <span class="p">))</span>

        <span class="c1"># Start retransmission timer</span>
        <span class="n">RetransmissionTimer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">buffer_entry</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">next_seq_num</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</code></pre></div>
<p>The sender can have <code>window_size</code> unacknowledged packets in flight.
This maintains throughput even with high latency:
new packets are being sent while waiting for ACKs from earlier packets.</p>
<h2>Retransmission on Timeout</h2>
<p>If an ACK doesn't arrive within the timeout period, the segment is retransmitted.
We use a separate <code>Process</code> for each retransmission timer:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">RetransmissionTimer</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Timer process for retransmitting unacknowledged segments."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">:</span> <span class="s1">'TCPConnection'</span><span class="p">,</span> <span class="n">segment</span><span class="p">:</span> <span class="n">SegmentBuffer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">connection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="n">segment</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Wait for timeout, then retransmit if not acknowledged."""</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">rto</span><span class="p">)</span>

        <span class="c1"># Check if still in send buffer (not yet acknowledged)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">send_buffer</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] TCP: TIMEOUT - Retransmitting "</span>
                  <span class="sa">f</span><span class="s2">"seq=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">seq_num</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">packets_retransmitted</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">retransmit_count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Retransmit</span>
            <span class="n">packet</span> <span class="o">=</span> <span class="n">Packet</span><span class="p">(</span>
                <span class="n">src_addr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">local_addr</span><span class="p">,</span>
                <span class="n">dst_addr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">remote_addr</span><span class="p">,</span>
                <span class="n">seq_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">seq_num</span><span class="p">,</span>
                <span class="n">packet_type</span><span class="o">=</span><span class="n">PacketType</span><span class="o">.</span><span class="n">DATA</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">data</span>
            <span class="p">)</span>

            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">send_packet</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>

            <span class="c1"># Restart timer</span>
            <span class="n">RetransmissionTimer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="p">)</span>
</code></pre></div>
<p>When sending a segment, we create a <code>RetransmissionTimer</code> <code>Process</code>:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="c1"># In TCPConnection.send():</span>
<span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">send_packet</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>

<span class="c1"># Add to send buffer</span>
<span class="bp">self</span><span class="o">.</span><span class="n">send_buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">buffer_entry</span><span class="p">)</span>

<span class="c1"># Start retransmission timer</span>
<span class="n">RetransmissionTimer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">buffer_entry</span><span class="p">)</span>
</code></pre></div>
<p>Each segment has its own timer <code>Process</code>.
If the segment hasn't been acknowledged (i.e., is still in the send buffer)
when the timer expires,
it is retransmitted and a new timer starts.</p>
<h2>Handling Out-of-Order Delivery</h2>
<p>The receive buffer handles segments arriving out of order:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ReceiveBuffer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Buffer for out-of-order received segments."""</span>
    <span class="n">segments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">next_expected_seq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Add a segment to the receive buffer."""</span>
        <span class="k">if</span> <span class="n">seq_num</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_expected_seq</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">seq_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_continuous_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Extract continuous data starting from next_expected_seq."""</span>
        <span class="n">result</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">""</span>
        <span class="n">current_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_expected_seq</span>

        <span class="k">while</span> <span class="n">current_seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="n">segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">current_seq</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">segment</span>
            <span class="n">current_seq</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next_expected_seq</span> <span class="o">=</span> <span class="n">current_seq</span>

        <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
<p>Segments are held until all gaps are filled.
When a contiguous block of data is available, it's delivered to the application in order.</p>
<h2>Cumulative Acknowledgments</h2>
<p>TCP uses cumulative ACKs,
i.e.,
each ACK indicates all data up to a sequence number has been received:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">handle_ack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">packet</span><span class="p">:</span> <span class="n">Packet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Handle ACK packet."""</span>
    <span class="n">ack_num</span> <span class="o">=</span> <span class="n">packet</span><span class="o">.</span><span class="n">ack_num</span>

    <span class="c1"># Remove acknowledged segments from send buffer</span>
    <span class="n">acknowledged</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_buffer</span><span class="p">[:]:</span>
        <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">seq_num</span> <span class="o">&lt;</span> <span class="n">ack_num</span><span class="p">:</span>
            <span class="n">acknowledged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send_buffer</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">acknowledged</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_base</span> <span class="o">=</span> <span class="n">ack_num</span>
</code></pre></div>
<p>A single ACK can acknowledge multiple segments.
This is simpler than selective acknowledgments and works well when most data arrives in order.</p>
<h2>Basic Example</h2>
<p>Let's see TCP in action:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">run_basic_tcp</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Demonstrate basic TCP communication."""</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>

    <span class="c1"># Create unreliable network</span>
    <span class="n">network</span> <span class="o">=</span> <span class="n">UnreliableNetwork</span><span class="p">(</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">loss_rate</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span>      <span class="c1"># 15% packet loss</span>
        <span class="n">reorder_rate</span><span class="o">=</span><span class="mf">0.10</span><span class="p">,</span>   <span class="c1"># 10% reordering</span>
        <span class="n">duplicate_rate</span><span class="o">=</span><span class="mf">0.05</span>  <span class="c1"># 5% duplication</span>
    <span class="p">)</span>

    <span class="c1"># Create server connection</span>
    <span class="n">server_conn</span> <span class="o">=</span> <span class="n">TCPConnection</span><span class="p">(</span>
        <span class="n">env</span><span class="p">,</span> <span class="s2">"192.168.1.100"</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span> <span class="n">network</span>
    <span class="p">)</span>

    <span class="c1"># Create client connection</span>
    <span class="n">client_conn</span> <span class="o">=</span> <span class="n">TCPConnection</span><span class="p">(</span>
        <span class="n">env</span><span class="p">,</span> <span class="s2">"192.168.1.101"</span><span class="p">,</span> <span class="mi">9000</span><span class="p">,</span> <span class="n">network</span>
    <span class="p">)</span>

    <span class="c1"># Create applications</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">TCPServer</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">server_conn</span><span class="p">)</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">TCPClient</span><span class="p">(</span>
        <span class="n">env</span><span class="p">,</span> <span class="n">client_conn</span><span class="p">,</span> <span class="s2">"192.168.1.100"</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span>
        <span class="s2">"Hello from TCP! This will arrive reliably despite packet loss."</span>
    <span class="p">)</span>

    <span class="c1"># Run simulation</span>
    <span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</code></pre></div>
<p>Despite 15% packet loss and reordering,
TCP successfully delivers the complete message in order.</p>
<h2>High Loss Scenario</h2>
<p>Let's test TCP under extreme conditions:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">run_high_loss_scenario</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Demonstrate TCP under high packet loss."""</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>

    <span class="c1"># Extremely unreliable network</span>
    <span class="n">network</span> <span class="o">=</span> <span class="n">UnreliableNetwork</span><span class="p">(</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">loss_rate</span><span class="o">=</span><span class="mf">0.40</span><span class="p">,</span>      <span class="c1"># 40% packet loss!</span>
        <span class="n">reorder_rate</span><span class="o">=</span><span class="mf">0.20</span><span class="p">,</span>   <span class="c1"># 20% reordering</span>
        <span class="n">duplicate_rate</span><span class="o">=</span><span class="mf">0.10</span>  <span class="c1"># 10% duplication</span>
    <span class="p">)</span>

    <span class="c1"># TCP with aggressive retransmission</span>
    <span class="n">server_conn</span> <span class="o">=</span> <span class="n">TCPConnection</span><span class="p">(</span>
        <span class="n">env</span><span class="p">,</span> <span class="s2">"10.0.0.1"</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span>
        <span class="n">window_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">timeout</span><span class="o">=</span><span class="mf">1.0</span>  <span class="c1"># Faster retransmit</span>
    <span class="p">)</span>

    <span class="n">client_conn</span> <span class="o">=</span> <span class="n">TCPConnection</span><span class="p">(</span>
        <span class="n">env</span><span class="p">,</span> <span class="s2">"10.0.0.2"</span><span class="p">,</span> <span class="mi">6000</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span>
        <span class="n">window_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">timeout</span><span class="o">=</span><span class="mf">1.0</span>
    <span class="p">)</span>

    <span class="c1"># Transfer larger message</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">TCPServer</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">server_conn</span><span class="p">)</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">TCPClient</span><span class="p">(</span>
        <span class="n">env</span><span class="p">,</span> <span class="n">client_conn</span><span class="p">,</span> <span class="s2">"10.0.0.1"</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span>
        <span class="s2">"This is a much longer message that will be split into multiple "</span>
        <span class="s2">"segments. Despite 40% packet loss, TCP will successfully deliver "</span>
        <span class="s2">"every byte through retransmission. "</span> <span class="o">*</span> <span class="mi">5</span>
    <span class="p">)</span>

    <span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
</code></pre></div>
<p>Even with 40% loss, TCP delivers the complete message.
You'll see many retransmissions but eventual success.</p>
<h2>Key TCP Concepts</h2>
<p><strong>Sequence Number Space</strong>:
Each byte transmitted has a unique sequence number.
For a message "Hello":</p>
<ul>
<li>Byte 'H' might be seq=1000</li>
<li>Byte 'e' is seq=1001</li>
<li>Byte 'l' is seq=1002</li>
<li>And so on...</li>
</ul>
<p>When acknowledging, the receiver sends back seq=1005,
meaning, "I've received everything up to 1005."</p>
<p><strong>Window Size and Throughput</strong>:
The window size determines maximum throughput.
With:</p>
<ul>
<li>Window size = 4 segments</li>
<li>Segment size = 1000 bytes</li>
<li>Round-trip time = 0.5 seconds</li>
</ul>
<p>the maximum throughput is approximately (4 × 1000) / 0.5 = 8000 bytes/second.
Larger windows enable higher throughput but require more buffering.</p>
<p><strong>Adaptive Retransmission</strong>:
Our implementation uses a fixed timeout.
Real TCP measures round-trip time and adapts the timeout:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="n">RTO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">smoothed_RTT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">RTT_variance</span>
</code></pre></div>
<p>This balances responsiveness (short timeout) with avoiding spurious retransmissions (long timeout).</p>
<p><strong>Fast Retransmit</strong>:
An optimization not in our implementation
is that if the sender receives three duplicate ACKs for the same sequence number,
it immediately retransmits without waiting for timeout.
This recovers from loss faster.</p>
<h2>Real-World Considerations</h2>
<p>Production TCP implementations include features we've omitted:</p>
<ul>
<li>
<p><strong>Selective Acknowledgments (SACK)</strong> acknowledge non-contiguous blocks of data,
    which allows efficient retransmission of only the missing segments.</p>
</li>
<li>
<p><strong>Congestion Control</strong>:
    Adapt sending rate to network capacity using algorithms like:</p>
<ul>
<li><strong>Slow Start</strong>: Exponentially increase window until loss detected</li>
<li><strong>Congestion Avoidance</strong>: Linearly increase window</li>
<li><strong>Fast Recovery</strong>: Reduce window on loss, then recover</li>
</ul>
</li>
<li>
<p><strong>Nagle's Algorithm</strong> batches small writes to reduce overhead.</p>
</li>
<li>
<p><strong>Path MTU Discovery</strong>
    determines maximum packet size without fragmentation by testing increasingly large packets.</p>
</li>
<li>
<p><strong>Timestamp Options</strong>
    improve RTT estimation and detect wrapped sequence numbers on high-speed networks.</p>
</li>
</ul>
<h2>Performance Analysis</h2>
<p>Let's analyze our TCP implementation's efficiency:
With 15% loss and 4-segment window:</p>
<ul>
<li>approximately 15% of packets need retransmission;</li>
<li>the window allows 4 segments in flight; and</li>
<li>the average delay per segment is approximately RTT + (loss_rate × timeout)</li>
</ul>
<p>The throughput efficiency is therefore</p>
<div class="codehilite"><pre class=""><span></span><code>efficiency = successful_transmission_rate / available_bandwidth
           ≈ (1 - loss_rate) / (1 + loss_rate × retransmissions)
</code></pre></div>
<h2>Conclusion</h2>
<p>Building TCP on UDP reveals how reliability emerges from unreliable components.
The key principles are:</p>
<ol>
<li><strong>Sequence numbers</strong> enable detecting loss and reordering</li>
<li><strong>Acknowledgments</strong> confirm successful delivery</li>
<li><strong>Retransmission timers</strong> recover from packet loss</li>
<li><strong>Sliding windows</strong> maintain throughput despite latency</li>
<li><strong>Cumulative ACKs</strong> simplify acknowledgment logic</li>
</ol>
<p>These patterns appear throughout distributed systems:</p>
<ul>
<li><strong>Message queues</strong> use similar acknowledgment schemes</li>
<li><strong>Database replication</strong> uses sequence numbers for ordering</li>
<li><strong>Consensus protocols</strong> use timeouts for failure detection</li>
<li><strong>QUIC</strong> rebuilds TCP-like reliability over UDP for faster handshakes</li>
</ul>
</main>
<footer>
<div class="row">
<div class="col-3 left">
	  ⇐ <a href="../saga/">The Saga Pattern</a>
</div>
<div class="col-6 center">
<a href="../"></a>
	  © 2025
	  <a href="../#acknowledgments">the authors</a>
</div>
<div class="col-3 right">
<a href="../finale/">Conclusion</a> ⇒
	</div>
</div>
</footer>
</body>
</html>