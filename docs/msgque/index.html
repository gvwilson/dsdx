<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>A Message Queue with Publish-Subscribe</title>
<link href="../static/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="../static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../static/page.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav>
<a href="../">Home</a>
      ·
      <span class="dropdown">
<a href="#">Lessons</a>
<span class="dropdown-content" id="nav-lessons">
<a href="../intro/">Introduction</a>
<a href="../msgque/">A Message Queue</a>
<a href="../worksteal/">Work-Stealing Scheduler</a>
<a href="../tracing/">Distributed Tracing</a>
<a href="../crdt/">Conflict-Free Replicated Data Types</a>
<a href="../mapreduce/">MapReduce</a>
<a href="../oauth/">OAuth</a>
<a href="../distlock/">Distributed Locks</a>
<a href="../torrent/">BitTorrent</a>
<a href="../eventual/">Eventually Consistent Key-Value Store</a>
<a href="../saga/">The Saga Pattern</a>
<a href="../tcp/">TCP</a>
<a href="../finale/">Conclusion</a>
</span>
</span>
      ·
      <span class="dropdown">
<a href="#">Appendices</a>
<span class="dropdown-content" id="nav-appendices">
<a href="../license/">License</a>
<a href="../conduct/">Code of Conduct</a>
<a href="../contributing/">Contributing</a>
<a href="../bibliography/">Bibliography</a>
<a href="../glossary/">Glossary</a>
</span>
</span>
</nav>
<main>
<h1>A Message Queue with Publish-Subscribe</h1>
<p>Real-world distributed systems need a way for components to communicate without being tightly coupled.
When a web server processes an order, it might need to notify the inventory system, trigger an email, update analytics, and log the transaction.
If the web server called each of these services directly, a failure in any one would block the entire operation.
This is where message queues come in.</p>
<p>Systems like <a href="https://www.rabbitmq.com/">RabbitMQ</a>, <a href="https://kafka.apache.org/">Apache Kafka</a>, and <a href="https://aws.amazon.com/sqs/">Amazon SQS</a>
act as intermediaries that decouple message producers from consumers.
A publisher sends messages to a named topic without knowing who (if anyone) will receive them.
Subscribers express interest in topics and receive messages asynchronously, processing them at their own pace.
This pattern is fundamental to event-driven architectures used throughout the industry—from LinkedIn's data pipeline that processes billions of events daily, to Netflix's recommendation engine that reacts to viewing patterns, to real-time analytics platforms that aggregate clickstream data.</p>
<h2>Understanding the Publish-Subscribe Pattern</h2>
<p>In the publish-subscribe pattern, publishers send messages to topics (sometimes called channels or exchanges).
The message broker maintains subscriptions—mappings from topics to interested consumers.
When a message arrives, the broker delivers it to all current subscribers of that topic.
This is called fan-out: one message can reach many consumers.</p>
<p>The pattern provides several crucial benefits.
First, publishers and subscribers don't need to know about each other—they only share knowledge of topic names.
Second, the system can scale independently: you can add more publishers or subscribers without modifying existing code.
Third, the broker provides buffering: if consumers are slow or temporarily unavailable, messages wait in queues rather than being lost.</p>
<h2>Our Implementation</h2>
<p>We'll build a message queue system using asimpy, a discrete event simulation framework based on Python's async/await syntax.
Asimpy lets us model concurrent systems using coroutines without dealing with actual threads or network connections.
This makes the code simpler and deterministic—perfect for understanding the core concepts.</p>
<p>Our system has three main components: publishers that send messages, a broker that routes messages to topics, and subscribers that receive and process messages.
Let's start with the message broker itself:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Message</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""A message sent through the queue system."""</span>
    <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">timestamp</span><span class="p">:</span> <span class="nb">float</span>
</code></pre></div>
<p>The <code>Message</code> class represents data flowing through our system.
Each message has a topic (like "orders" or "user-activity"), content (the actual data), a unique ID, and a timestamp.
In a real system, messages would contain rich structured data, but strings are sufficient for our example.</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">MessageBroker</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""A message broker that routes messages to topic subscribers."""</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer_size</span>
        <span class="c1"># Topics map to lists of subscriber queues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Queue</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="c1"># Statistics for observability</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_published</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_delivered</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">subscribe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Queue</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Create a queue for a subscriber to a topic."""</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="p">[</span><span class="n">topic</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">queue</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">publish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Publish a message to all subscribers of its topic."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_published</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Find all subscriber queues for this topic</span>
        <span class="n">queues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">queues</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] No subscribers for topic '</span><span class="si">{</span><span class="n">message</span><span class="o">.</span><span class="n">topic</span><span class="si">}</span><span class="s2">'"</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Deliver to each subscriber's queue</span>
        <span class="k">for</span> <span class="n">queue</span> <span class="ow">in</span> <span class="n">queues</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">messages_delivered</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>
<p>The broker maintains a dictionary mapping topics to lists of queues.
When a message is published, the broker looks up the topic and places the message in each subscriber's queue.
Using separate queues per subscriber ensures that a slow consumer doesn't block others—this is a key property of the pattern.</p>
<p>Unlike many message queue implementations that would drop messages when queues fill up, our asimpy queues grow unbounded.
In a real system, you'd want to enforce limits and implement backpressure or message dropping policies.
We'll discuss delivery semantics later.</p>
<p>Now let's implement publishers.
A publisher sends messages to topics at some rate:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Publisher</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Publishes messages to topics."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">broker</span><span class="p">:</span> <span class="n">MessageBroker</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broker</span> <span class="o">=</span> <span class="n">broker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topic</span> <span class="o">=</span> <span class="n">topic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Generate and publish messages."""</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Create a message</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">message_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">Message</span><span class="p">(</span>
                <span class="n">topic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span>
                <span class="n">content</span><span class="o">=</span><span class="sa">f</span><span class="s2">"Message </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">message_counter</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span>
                <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">message_counter</span><span class="p">,</span>
                <span class="n">timestamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span>
            <span class="p">)</span>

            <span class="c1"># Publish it</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> publishing: </span><span class="si">{</span><span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">broker</span><span class="o">.</span><span class="n">publish</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

            <span class="c1"># Wait before next message</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span>
</code></pre></div>
<p>This publisher sends messages at regular intervals.
Real publishers would react to external events (like HTTP requests or database changes), but timed generation works well for simulation.
The <code>await self.timeout()</code> pauses this process and resumes after the specified time.</p>
<p>Notice that we inherit from <code>Process</code>, which is asimpy's base class for active components.
The <code>init()</code> method is called during construction to set up our state, and <code>run()</code> is the coroutine that defines the publisher's behavior.</p>
<p>Finally, subscribers receive and process messages:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Subscriber</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Subscribes to topics and processes messages."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">broker</span><span class="p">:</span> <span class="n">MessageBroker</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">topics</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> 
             <span class="n">processing_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broker</span> <span class="o">=</span> <span class="n">broker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topics</span> <span class="o">=</span> <span class="n">topics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_time</span> <span class="o">=</span> <span class="n">processing_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_received</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Subscribe to all topics and get a queue for each</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queues</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">topic</span> <span class="ow">in</span> <span class="n">topics</span><span class="p">:</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="n">broker</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">topic</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queues</span><span class="p">[</span><span class="n">topic</span><span class="p">]</span> <span class="o">=</span> <span class="n">queue</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Process messages from subscribed topics."""</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Wait for a message from any queue</span>
            <span class="c1"># Build a dict of topic -&gt; get() coroutines</span>
            <span class="n">get_operations</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">topic</span><span class="p">:</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> 
                <span class="k">for</span> <span class="n">topic</span><span class="p">,</span> <span class="n">queue</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">queues</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="c1"># Wait for the first one to complete</span>
            <span class="n">topic</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="k">await</span> <span class="n">FirstOf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="o">**</span><span class="n">get_operations</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">messages_received</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">latency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="n">message</span><span class="o">.</span><span class="n">timestamp</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> received from '</span><span class="si">{</span><span class="n">topic</span><span class="si">}</span><span class="s2">': "</span>
                  <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="si">}</span><span class="s2"> (latency: </span><span class="si">{</span><span class="n">latency</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>

            <span class="c1"># Simulate processing time</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_time</span><span class="p">)</span>
</code></pre></div>
<p>The subscriber uses asimpy's <code>FirstOf</code> to wait on multiple queues simultaneously—whichever queue has a message first will complete.
This is more elegant than round-robin polling.
Real implementations use event-driven APIs or threads, but <code>FirstOf</code> captures the same semantics: we wait for any subscribed topic to produce a message.</p>
<p>The key point is that processing happens asynchronously: the subscriber takes messages from its queues and processes them at its own pace, independently of the publishers and other subscribers.</p>
<h2>Running a Simulation</h2>
<p>Let's create a scenario with multiple publishers and subscribers to see the system in action:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">run_simulation</span><span class="p">():</span>
<span class="w">    </span><span class="sd">"""Run a simulation of the message queue system."""</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
    <span class="n">broker</span> <span class="o">=</span> <span class="n">MessageBroker</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="c1"># Create publishers</span>
    <span class="n">order_pub</span> <span class="o">=</span> <span class="n">Publisher</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">broker</span><span class="p">,</span> <span class="s2">"OrderService"</span><span class="p">,</span> <span class="s2">"orders"</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="n">user_pub</span> <span class="o">=</span> <span class="n">Publisher</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">broker</span><span class="p">,</span> <span class="s2">"UserService"</span><span class="p">,</span> <span class="s2">"user-activity"</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>

    <span class="c1"># Create subscribers</span>
    <span class="c1"># Fast subscriber handling orders</span>
    <span class="n">inventory</span> <span class="o">=</span> <span class="n">Subscriber</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">broker</span><span class="p">,</span> <span class="s2">"Inventory"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"orders"</span><span class="p">],</span> 
                          <span class="n">processing_time</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># Slow subscriber handling orders</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">Subscriber</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">broker</span><span class="p">,</span> <span class="s2">"Email"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"orders"</span><span class="p">],</span> 
                      <span class="n">processing_time</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>

    <span class="c1"># Subscriber handling multiple topics</span>
    <span class="n">analytics</span> <span class="o">=</span> <span class="n">Subscriber</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">broker</span><span class="p">,</span> <span class="s2">"Analytics"</span><span class="p">,</span> 
                          <span class="p">[</span><span class="s2">"orders"</span><span class="p">,</span> <span class="s2">"user-activity"</span><span class="p">],</span> 
                          <span class="n">processing_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># Run simulation</span>
    <span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

    <span class="c1"># Print statistics</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">=== Statistics ==="</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Messages published: </span><span class="si">{</span><span class="n">broker</span><span class="o">.</span><span class="n">messages_published</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Messages delivered: </span><span class="si">{</span><span class="n">broker</span><span class="o">.</span><span class="n">messages_delivered</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Inventory received: </span><span class="si">{</span><span class="n">inventory</span><span class="o">.</span><span class="n">messages_received</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Email received: </span><span class="si">{</span><span class="n">email</span><span class="o">.</span><span class="n">messages_received</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Analytics received: </span><span class="si">{</span><span class="n">analytics</span><span class="o">.</span><span class="n">messages_received</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">run_simulation</span><span class="p">()</span>
</code></pre></div>
<p>When you run this code, you'll see messages being published and consumed asynchronously.
Notice how the fast Inventory service keeps up with orders, while the slow Email service falls behind.
Messages queue up waiting for processing—this is the buffering we mentioned earlier.</p>
<p>The Analytics service receives messages from multiple topics, demonstrating how subscribers can aggregate different event streams.
This is common in real systems: a data warehouse might subscribe to dozens of topics to build a complete picture of system activity.</p>
<h2>Delivery Guarantees</h2>
<p>Our implementation provides unbounded queuing, which means messages are never dropped (assuming infinite memory).
This is closer to "at-least-once" delivery, though we haven't implemented acknowledgments or redelivery on failure.
Let's discuss the spectrum of delivery guarantees:</p>
<ul>
<li>
<p><strong>At-most-once delivery</strong> ensures that messages are delivered zero or one time—never duplicated, but possibly lost.
This is achieved by dropping messages when queues are full or when subscribers are unavailable.
It's the weakest guarantee but the simplest to implement and the fastest.</p>
</li>
<li>
<p><strong>At-least-once delivery</strong> ensures every message is delivered, possibly multiple times.
This requires acknowledgments: the broker keeps messages until subscribers confirm receipt.
If a subscriber crashes before acknowledging, the broker redelivers to another subscriber or retries.
Kafka and RabbitMQ support this mode.</p>
</li>
<li>
<p><strong>Exactly-once delivery</strong> is the strongest guarantee: each message is processed exactly once.
This is surprisingly difficult in distributed systems due to failures and network issues.
Kafka achieves this through idempotent producers and transactional consumers—essentially assigning each message a unique ID and having consumers track which IDs they've processed.</p>
</li>
</ul>
<p>Here's how we could extend our broker to support at-least-once delivery with acknowledgments:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">AckMessage</span><span class="p">(</span><span class="n">Message</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Message that requires acknowledgment."""</span>
    <span class="n">ack_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AckBroker</span><span class="p">(</span><span class="n">MessageBroker</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Broker with acknowledgment support."""</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> 
                 <span class="n">ack_timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ack_timeout</span> <span class="o">=</span> <span class="n">ack_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_acks</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># ack_id -&gt; (message, timestamp, queue)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_ack_id</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">publish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Publish with ack tracking."""</span>
        <span class="n">queues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">for</span> <span class="n">queue</span> <span class="ow">in</span> <span class="n">queues</span><span class="p">:</span>
            <span class="n">ack_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_ack_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next_ack_id</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">ack_msg</span> <span class="o">=</span> <span class="n">AckMessage</span><span class="p">(</span>
                <span class="n">topic</span><span class="o">=</span><span class="n">message</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span>
                <span class="n">content</span><span class="o">=</span><span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">,</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">message</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                <span class="n">timestamp</span><span class="o">=</span><span class="n">message</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span>
                <span class="n">ack_id</span><span class="o">=</span><span class="n">ack_id</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pending_acks</span><span class="p">[</span><span class="n">ack_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ack_msg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
            <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">ack_msg</span><span class="p">)</span>

            <span class="c1"># Schedule redelivery if not acked</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ack_timeout</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">aid</span><span class="o">=</span><span class="n">ack_id</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_ack</span><span class="p">(</span><span class="n">aid</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">acknowledge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ack_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Acknowledge receipt of a message."""</span>
        <span class="k">if</span> <span class="n">ack_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_acks</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_acks</span><span class="p">[</span><span class="n">ack_id</span><span class="p">]</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_check_ack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ack_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Redeliver if not acknowledged."""</span>
        <span class="k">if</span> <span class="n">ack_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_acks</span><span class="p">:</span>
            <span class="n">msg</span><span class="p">,</span> <span class="n">original_time</span><span class="p">,</span> <span class="n">queue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_acks</span><span class="p">[</span><span class="n">ack_id</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] Redelivering </span><span class="si">{</span><span class="n">msg</span><span class="o">.</span><span class="n">content</span><span class="si">}</span><span class="s2"> "</span>
                  <span class="sa">f</span><span class="s2">"(ack_id </span><span class="si">{</span><span class="n">ack_id</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
            <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</code></pre></div>
<p>A subscriber using this broker would call <code>broker.acknowledge(message.ack_id)</code> after successfully processing each message.
Messages not acknowledged within the timeout would be redelivered.</p>
<h2>Consumer Groups and Load Balancing</h2>
<p>In production systems, we often want multiple instances of the same subscriber type to share the workload.
This is called a consumer group: messages on a topic are distributed among group members rather than duplicated to each.
Here's a simple implementation:</p>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ConsumerGroup</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Distribute messages among multiple consumers."""</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">broker</span><span class="p">:</span> <span class="n">MessageBroker</span><span class="p">,</span> 
                 <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">num_consumers</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">broker</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">topic</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consumers</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Create consumer queues for load balancing</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_consumers</span><span class="p">):</span>
            <span class="n">consumer_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">consumers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">consumer_queue</span><span class="p">)</span>

        <span class="c1"># Start distributor process</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distributor</span> <span class="o">=</span> <span class="n">_Distributor</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumers</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_consumer_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Queue</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Get queue for a specific consumer in the group."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

<span class="k">class</span><span class="w"> </span><span class="nc">_Distributor</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Distribute messages round-robin to consumers."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">destinations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Queue</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span> <span class="o">=</span> <span class="n">destinations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_dest</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Forward messages to consumers in round-robin order."""</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">next_dest</span><span class="p">]</span>
            <span class="k">await</span> <span class="n">dest</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next_dest</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">next_dest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">)</span>
</code></pre></div>
<p>This consumer group receives messages from the broker on a single queue, then distributes them round-robin to individual consumer queues.
Each consumer in the group processes a subset of the messages, enabling parallel processing.
Real systems use more sophisticated load balancing—weighted distribution, least-loaded routing, or partition-based assignment.</p>
<h2>Conclusion</h2>
<p>The publish-subscribe pattern decouples system components, enabling independent scaling and evolution.
By routing messages through a broker, we gain buffering, fan-out, and fault tolerance.
The pattern appears throughout modern architectures: microservices use it for inter-service communication, frontend applications use it for real-time updates, and data pipelines use it for stream processing.</p>
<p>The code we've written captures the essential ideas: topics, subscriptions, asynchronous delivery, and queuing.
We've seen how asimpy's async/await syntax makes concurrent behavior natural to express, and how <code>FirstOf</code> enables waiting on multiple message sources simultaneously.
Real systems add persistence (writing messages to disk), replication (for fault tolerance), partitioning (for parallelism), and sophisticated delivery semantics.
But the core pattern remains the same: publishers and subscribers communicate through topics, with a broker managing the complexity in between.</p>
</main>
<footer>
<div class="row">
<div class="col-3 left">
	  ⇐ <a href="../intro/">Introduction</a>
</div>
<div class="col-6 center">
<a href="../"></a>
	  © 2025
	  <a href="../#acknowledgments">the authors</a>
</div>
<div class="col-3 right">
<a href="../worksteal/">Work-Stealing Scheduler</a> ⇒
	</div>
</div>
</footer>
</body>
</html>