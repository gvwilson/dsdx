<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>A Message Queue with Publish-Subscribe</title>
<link href="../static/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="../static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../static/page.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav>
<a href="../">Home</a>
      ·
      <span class="dropdown">
<a href="#">Lessons</a>
<span class="dropdown-content" id="nav-lessons">
<a href="../intro/">Introduction</a>
<a href="../msgque/">A Message Queue</a>
<a href="../worksteal/">Work-Stealing Scheduler</a>
<a href="../tracing/">Distributed Tracing</a>
<a href="../crdt/">Conflict-Free Replicated Data Types</a>
<a href="../mapreduce/">MapReduce</a>
<a href="../oauth/">OAuth</a>
<a href="../distlock/">Distributed Locks</a>
<a href="../torrent/">BitTorrent</a>
<a href="../eventual/">Eventually Consistent Key-Value Store</a>
<a href="../saga/">The Saga Pattern</a>
<a href="../tcp/">TCP</a>
<a href="../finale/">Conclusion</a>
</span>
</span>
      ·
      <span class="dropdown">
<a href="#">Appendices</a>
<span class="dropdown-content" id="nav-appendices">
<a href="../license/">License</a>
<a href="../conduct/">Code of Conduct</a>
<a href="../contributing/">Contributing</a>
<a href="../bibliography/">Bibliography</a>
<a href="../glossary/">Glossary</a>
</span>
</span>
</nav>
<main>
<h1>A Message Queue with Publish-Subscribe</h1>
<p>Real-world distributed systems need a way for components to communicate without being tightly coupled.
When a web server processes an order, it might need to notify the inventory system, trigger an email, update analytics, and log the transaction.
If the web server called each of these services directly, a failure in any one would block the entire operation.
This is where message queues come in.</p>
<p>Systems like <a href="https://www.rabbitmq.com/">RabbitMQ</a>, <a href="https://kafka.apache.org/">Apache Kafka</a>, and <a href="https://aws.amazon.com/sqs/">Amazon SQS</a>
act as intermediaries that decouple message producers from consumers.
A publisher sends messages to a named topic without knowing who (if anyone) will receive them.
Subscribers express interest in topics and receive messages asynchronously, processing them at their own pace.
This pattern is fundamental to event-driven architectures used throughout the industry—from LinkedIn's data pipeline that processes billions of events daily, to Netflix's recommendation engine that reacts to viewing patterns, to real-time analytics platforms that aggregate clickstream data.</p>
<h2>Understanding the Publish-Subscribe Pattern</h2>
<p>In the publish-subscribe pattern, publishers send messages to topics (sometimes called channels or exchanges).
The message broker maintains subscriptions—mappings from topics to interested consumers.
When a message arrives, the broker delivers it to all current subscribers of that topic.
This is called fan-out: one message can reach many consumers.</p>
<p>The pattern provides several crucial benefits.
First, publishers and subscribers don't need to know about each other—they only share knowledge of topic names.
Second, the system can scale independently: you can add more publishers or subscribers without modifying existing code.
Third, the broker provides buffering: if consumers are slow or temporarily unavailable, messages wait in queues rather than being lost.</p>
<h2>Our Implementation</h2>
<p>We'll build a message queue system using asimpy, a discrete event simulation framework based on Python's async/await syntax.
Asimpy lets us model concurrent systems using coroutines without dealing with actual threads or network connections.
This makes the code simpler and deterministic—perfect for understanding the core concepts.</p>
<p>Our system has three main components: publishers that send messages, a broker that routes messages to topics, and subscribers that receive and process messages.
Let's start with the message broker itself:</p>
<div data-filter="inc=message" data-inc="message.py"><div class="codehilite"><pre class=""><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Message</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""A message sent through the queue system."""</span>

    <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">timestamp</span><span class="p">:</span> <span class="nb">float</span>
</code></pre></div>
</div>
<p>The <code>Message</code> class represents data flowing through our system.
Each message has a topic (like "orders" or "user-activity"), content (the actual data), a unique ID, and a timestamp.
In a real system, messages would contain rich structured data, but strings are sufficient for our example.</p>
<div data-filter="inc=broker" data-inc="broker.py"><div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">MessageBroker</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""A message broker that routes messages to topic subscribers."""</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Queue</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_published</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_delivered</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">subscribe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Queue</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Create a queue for a subscriber to a topic."""</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="p">[</span><span class="n">topic</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">queue</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">publish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Publish a message to all subscribers of its topic."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_published</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">queues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">for</span> <span class="n">queue</span> <span class="ow">in</span> <span class="n">queues</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">messages_delivered</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>
</div>
<p>The broker maintains a dictionary mapping topics to lists of queues.
When a message is published, the broker looks up the topic and places the message in each subscriber's queue.
Using separate queues per subscriber ensures that a slow consumer doesn't block others—this is a key property of the pattern.</p>
<p>Unlike many message queue implementations that would drop messages when queues fill up, our asimpy queues grow unbounded.
In a real system, you'd want to enforce limits and implement backpressure or message dropping policies.
We'll discuss delivery semantics later.</p>
<p>Now let's implement publishers.
A publisher sends messages to topics at some rate:</p>
<div data-filter="inc=publisher" data-inc="publisher.py"><div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Publisher</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Publishes messages to topics."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">broker</span><span class="p">:</span> <span class="s2">"MessageBroker"</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broker</span> <span class="o">=</span> <span class="n">broker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topic</span> <span class="o">=</span> <span class="n">topic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Generate and publish messages."""</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Create message.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">message_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">Message</span><span class="p">(</span>
                <span class="n">topic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span>
                <span class="n">content</span><span class="o">=</span><span class="sa">f</span><span class="s2">"Message </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">message_counter</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span>
                <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">message_counter</span><span class="p">,</span>
                <span class="n">timestamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Publish message.</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> publishing: </span><span class="si">{</span><span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">broker</span><span class="o">.</span><span class="n">publish</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

            <span class="c1"># Wait.</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span>
</code></pre></div>
</div>
<p>This publisher sends messages at regular intervals.
Real publishers would react to external events (like HTTP requests or database changes), but timed generation works well for simulation.
The <code>await self.timeout()</code> pauses this process and resumes after the specified time.</p>
<p>Notice that we inherit from <code>Process</code>, which is asimpy's base class for active components.
The <code>init()</code> method is called during construction to set up our state, and <code>run()</code> is the coroutine that defines the publisher's behavior.</p>
<p>Finally, subscribers receive and process messages:</p>
<div data-filter="inc=subscriber" data-inc="subscriber.py"><div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Subscriber</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Subscribes to topics and processes messages."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">broker</span><span class="p">:</span> <span class="s2">"MessageBroker"</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">topics</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">processing_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broker</span> <span class="o">=</span> <span class="n">broker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topics</span> <span class="o">=</span> <span class="n">topics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_time</span> <span class="o">=</span> <span class="n">processing_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_received</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Subscribe to all topics and get a queue for each</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queues</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">topic</span> <span class="ow">in</span> <span class="n">topics</span><span class="p">:</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="n">broker</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">topic</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queues</span><span class="p">[</span><span class="n">topic</span><span class="p">]</span> <span class="o">=</span> <span class="n">queue</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Process messages from subscribed topics."""</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Wait for a message from any queue.</span>
            <span class="n">get_operations</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">topic</span><span class="p">:</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">topic</span><span class="p">,</span> <span class="n">queue</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">queues</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="n">topic</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="k">await</span> <span class="n">FirstOf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="o">**</span><span class="n">get_operations</span><span class="p">)</span>

            <span class="c1"># Report.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">messages_received</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">latency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="n">message</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> received from '</span><span class="si">{</span><span class="n">topic</span><span class="si">}</span><span class="s2">': "</span>
                <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="si">}</span><span class="s2"> (latency: </span><span class="si">{</span><span class="n">latency</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">)"</span>
            <span class="p">)</span>

            <span class="c1"># Simulate processing time.</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_time</span><span class="p">)</span>
</code></pre></div>
</div>
<p>The subscriber uses asimpy's <code>FirstOf</code> to wait on multiple queues simultaneously—whichever queue has a message first will complete.
This is more elegant than round-robin polling.
Real implementations use event-driven APIs or threads, but <code>FirstOf</code> captures the same semantics: we wait for any subscribed topic to produce a message.</p>
<p>The key point is that processing happens asynchronously: the subscriber takes messages from its queues and processes them at its own pace, independently of the publishers and other subscribers.</p>
<h2>Running a Simulation</h2>
<p>Let's create a scenario with multiple publishers and subscribers to see the system in action:</p>
<div data-filter="inc=simulate" data-inc="simulate.py"><div class="codehilite"><pre class=""><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">run_simulation</span><span class="p">():</span>
<span class="w">    </span><span class="sd">"""Run a simulation of the message queue system."""</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
    <span class="n">broker</span> <span class="o">=</span> <span class="n">MessageBroker</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="c1"># Publishers.</span>
    <span class="n">Publisher</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">broker</span><span class="p">,</span> <span class="s2">"OrderService"</span><span class="p">,</span> <span class="s2">"orders"</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="n">Publisher</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">broker</span><span class="p">,</span> <span class="s2">"UserService"</span><span class="p">,</span> <span class="s2">"user-activity"</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>

    <span class="c1"># Fast and slow subscribers.</span>
    <span class="n">inventory</span> <span class="o">=</span> <span class="n">Subscriber</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">broker</span><span class="p">,</span> <span class="s2">"Inventory"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"orders"</span><span class="p">],</span> <span class="n">processing_time</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">Subscriber</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">broker</span><span class="p">,</span> <span class="s2">"Email"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"orders"</span><span class="p">],</span> <span class="n">processing_time</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>

    <span class="c1"># Subscriber handling multiple topics.</span>
    <span class="n">analytics</span> <span class="o">=</span> <span class="n">Subscriber</span><span class="p">(</span>
        <span class="n">env</span><span class="p">,</span> <span class="n">broker</span><span class="p">,</span> <span class="s2">"Analytics"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"orders"</span><span class="p">,</span> <span class="s2">"user-activity"</span><span class="p">],</span> <span class="n">processing_time</span><span class="o">=</span><span class="mf">1.0</span>
    <span class="p">)</span>

    <span class="c1"># Run simulation and report.</span>
    <span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">=== Statistics ==="</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Messages published: </span><span class="si">{</span><span class="n">broker</span><span class="o">.</span><span class="n">messages_published</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Messages delivered: </span><span class="si">{</span><span class="n">broker</span><span class="o">.</span><span class="n">messages_delivered</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Inventory received: </span><span class="si">{</span><span class="n">inventory</span><span class="o">.</span><span class="n">messages_received</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Email received: </span><span class="si">{</span><span class="n">email</span><span class="o">.</span><span class="n">messages_received</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Analytics received: </span><span class="si">{</span><span class="n">analytics</span><span class="o">.</span><span class="n">messages_received</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>
</div>
<p>When we run this code, we see messages being published and consumed asynchronously.
Notice how the fast <code>Inventory</code> service keeps up with orders, while the slow <code>Email</code> service falls behind.
Messages queue up waiting for processing—this is the buffering we mentioned earlier.</p>
<p>The <code>Analytics</code> service receives messages from multiple topics,
demonstrating how subscribers can aggregate different event streams.
This is common in real systems: a data warehouse might subscribe to dozens of topics to build a complete picture of system activity.</p>
<h2>Backpressure and Flow Control</h2>
<p>So far, our broker uses unbounded queues that grow indefinitely.
This works in simulation but fails in production:
if publishers produce faster than subscribers consume, queues will eventually exhaust memory and crash the system.
The solution is <em>backpressure</em>—a mechanism where slow consumers signal upstream components to slow down.</p>
<p>Backpressure is fundamental to building robust distributed systems.
Without it, a single slow consumer can cascade failures throughout the system.
Consider a real-world scenario: during a traffic spike, your web servers might generate events faster than your analytics database can process them.
Without backpressure, the message queue fills up, runs out of memory, and crashes—taking down multiple services.</p>
<p>There are several strategies for implementing backpressure:</p>
<ol>
<li>
<p><strong>Bounded queues with blocking</strong>:
    Publishers block when queues are full, naturally slowing them down.
    This provides strong backpressure but can cause publishers to stall.</p>
</li>
<li>
<p><strong>Bounded queues with dropping</strong>:
    When queues are full, new messages are dropped.
    This keeps the system running but loses data.
    Often combined with metrics so operators know data is being lost.</p>
</li>
<li>
<p><strong>Adaptive rate limiting</strong>:
    Publishers monitor queue sizes or delivery failures and dynamically adjust their publishing rate.
    This is more complex but provides smooth behavior under load.</p>
</li>
<li>
<p><strong>Priority-based dropping</strong>:
    When backpressure occurs, drop low-priority messages first, preserving critical data.</p>
</li>
</ol>
<p>Let's implement bounded queues with message dropping and adaptive rate limiting:</p>
<div data-filter="inc=backpressure" data-inc="backpressure_broker.py"><div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BackpressureBroker</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""A message broker with backpressure support."""</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">max_queue_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_queue_size</span> <span class="o">=</span> <span class="n">max_queue_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Queue</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_published</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_delivered</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_dropped</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">subscribe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Queue</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Create a bounded queue for a subscriber to a topic."""</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">,</span> <span class="n">max_capacity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_queue_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="p">[</span><span class="n">topic</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">queue</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">publish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Publish a message, applying backpressure if queues are full.</span>
<span class="sd">        </span>
<span class="sd">        Returns True if message was delivered to all subscribers,</span>
<span class="sd">        False if any queue was full and message was dropped.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_published</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">queues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span> <span class="p">[])</span>
        
        <span class="n">all_delivered</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">queue</span> <span class="ow">in</span> <span class="n">queues</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">queue</span><span class="o">.</span><span class="n">is_full</span><span class="p">():</span>
                <span class="c1"># Queue is full - drop message for this subscriber</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">messages_dropped</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">all_delivered</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">messages_delivered</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="n">all_delivered</span>
</code></pre></div>
</div>
<p>The key change is using <code>Queue(env, capacity=max_queue_size)</code> to create bounded queues.
When a queue is full, we drop the message for that subscriber.
The broker returns <code>False</code> to signal backpressure to the publisher.</p>
<p>Now we need a publisher that responds to backpressure:</p>
<div data-filter="inc=backpressure_publisher" data-inc="backpressure_publisher.py"><div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BackpressurePublisher</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Publisher that adapts to backpressure signals."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">broker</span><span class="p">:</span> <span class="s2">"BackpressureBroker"</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">base_interval</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">backoff_multiplier</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broker</span> <span class="o">=</span> <span class="n">broker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topic</span> <span class="o">=</span> <span class="n">topic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_interval</span> <span class="o">=</span> <span class="n">base_interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backoff_multiplier</span> <span class="o">=</span> <span class="n">backoff_multiplier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_interval</span> <span class="o">=</span> <span class="n">base_interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backpressure_events</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Generate and publish messages, slowing down on backpressure."""</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Create message.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">message_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">Message</span><span class="p">(</span>
                <span class="n">topic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span>
                <span class="n">content</span><span class="o">=</span><span class="sa">f</span><span class="s2">"Message </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">message_counter</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span>
                <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">message_counter</span><span class="p">,</span>
                <span class="n">timestamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Publish message and check if it was delivered.</span>
            <span class="n">all_delivered</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">broker</span><span class="o">.</span><span class="n">publish</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">all_delivered</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> published: </span><span class="si">{</span><span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"(interval: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_interval</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s)"</span>
                <span class="p">)</span>
                <span class="c1"># Success - gradually return to base rate.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_interval</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_interval</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_interval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">base_interval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_interval</span> <span class="o">/</span> <span class="mf">1.5</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Backpressure detected - slow down.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">backpressure_events</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_interval</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backoff_multiplier</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> BACKPRESSURE - "</span>
                    <span class="sa">f</span><span class="s2">"slowing to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_interval</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s interval"</span>
                <span class="p">)</span>

            <span class="c1"># Wait before next message.</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_interval</span><span class="p">)</span>
</code></pre></div>
</div>
<p>This publisher implements exponential backoff:
when <code>publish()</code> returns <code>False</code>, it doubles its interval between messages.
When publishing succeeds, it gradually reduces the interval back to the base rate.
This creates a negative feedback loop that stabilizes the system under load.</p>
<p>Let's see backpressure in action:</p>
<div data-filter="inc=backpressure_simulation" data-inc="simulate_backpressure.py"><div class="codehilite"><pre class=""><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">run_backpressure_simulation</span><span class="p">():</span>
<span class="w">    </span><span class="sd">"""Demonstrate backpressure in action."""</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
    
    <span class="c1"># Small queue size to trigger backpressure quickly.</span>
    <span class="n">broker</span> <span class="o">=</span> <span class="n">BackpressureBroker</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">max_queue_size</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="c1"># Fast publisher.</span>
    <span class="n">fast_publisher</span> <span class="o">=</span> <span class="n">BackpressurePublisher</span><span class="p">(</span>
        <span class="n">env</span><span class="p">,</span> <span class="n">broker</span><span class="p">,</span> <span class="s2">"FastPublisher"</span><span class="p">,</span> <span class="s2">"events"</span><span class="p">,</span> <span class="n">base_interval</span><span class="o">=</span><span class="mf">0.5</span>
    <span class="p">)</span>

    <span class="c1"># Slow subscriber creates backpressure.</span>
    <span class="n">slow_subscriber</span> <span class="o">=</span> <span class="n">Subscriber</span><span class="p">(</span>
        <span class="n">env</span><span class="p">,</span> <span class="n">broker</span><span class="p">,</span> <span class="s2">"SlowSubscriber"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"events"</span><span class="p">],</span> <span class="n">processing_time</span><span class="o">=</span><span class="mf">2.0</span>
    <span class="p">)</span>

    <span class="c1"># Run simulation.</span>
    <span class="n">env</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">=== Backpressure Statistics ==="</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Messages published: </span><span class="si">{</span><span class="n">broker</span><span class="o">.</span><span class="n">messages_published</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Messages delivered: </span><span class="si">{</span><span class="n">broker</span><span class="o">.</span><span class="n">messages_delivered</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Messages dropped: </span><span class="si">{</span><span class="n">broker</span><span class="o">.</span><span class="n">messages_dropped</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Backpressure events: </span><span class="si">{</span><span class="n">fast_publisher</span><span class="o">.</span><span class="n">backpressure_events</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Final interval: </span><span class="si">{</span><span class="n">fast_publisher</span><span class="o">.</span><span class="n">current_interval</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">s"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Messages received: </span><span class="si">{</span><span class="n">slow_subscriber</span><span class="o">.</span><span class="n">messages_received</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>
</div>
<p>When you run this simulation,
you'll see the publisher start fast but encounter backpressure as the slow subscriber's queue fills.
The publisher adapts by slowing down,
and the system reaches equilibrium where the publishing rate matches the consumption rate.</p>
<p>This is exactly what happens in production systems.
RabbitMQ supports bounded queues and will reject publishes when queues are full.
Kafka uses partition limits and producer throttling.
AWS SQS returns backpressure signals when message rates exceed limits.</p>
<h2>Advanced Backpressure: Priority Queues</h2>
<p>In many real systems, not all messages have equal importance.
During backpressure, you might want to preserve high-priority messages while dropping low-priority ones.
Here's how to implement priority-based backpressure:</p>
<div data-filter="inc=priority_message" data-inc="priority_backpressure.py"><div class="codehilite"><pre class=""><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PriorityMessage</span><span class="p">(</span><span class="n">Message</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Message with priority level."""</span>

    <span class="n">priority</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Higher number = higher priority</span>
</code></pre></div>
</div>
<div data-filter="inc=priority_broker" data-inc="priority_backpressure.py"><div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">PriorityBackpressureBroker</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Broker that drops low-priority messages first under backpressure."""</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">max_queue_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_queue_size</span> <span class="o">=</span> <span class="n">max_queue_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Queue</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_published</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_delivered</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_dropped</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dropped_by_priority</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">subscribe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Queue</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Create a bounded queue for a subscriber to a topic."""</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_queue_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="p">[</span><span class="n">topic</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">queue</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">publish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">PriorityMessage</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Publish with priority-based backpressure handling."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages_published</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">queues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span> <span class="p">[])</span>

        <span class="n">all_delivered</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">queue</span> <span class="ow">in</span> <span class="n">queues</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">queue</span><span class="o">.</span><span class="n">is_full</span><span class="p">():</span>
                <span class="c1"># Queue full - check if we should drop this message</span>
                <span class="c1"># or evict a lower-priority one</span>
                <span class="k">if</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_evict_lower_priority</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
                    <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">messages_delivered</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Drop this message</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">messages_dropped</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dropped_by_priority</span><span class="p">[</span><span class="n">message</span><span class="o">.</span><span class="n">priority</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">all_delivered</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">messages_delivered</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">all_delivered</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_try_evict_lower_priority</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">:</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">new_message</span><span class="p">:</span> <span class="n">PriorityMessage</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Try to evict a lower-priority message to make room.</span>
<span class="sd">        </span>
<span class="sd">        Returns True if eviction succeeded, False otherwise.</span>
<span class="sd">        """</span>
        <span class="c1"># In a real system, we'd inspect the queue and evict the</span>
        <span class="c1"># lowest-priority message. For this example, we'll use a</span>
        <span class="c1"># simple heuristic: if the new message has priority &gt; 5,</span>
        <span class="c1"># assume we can evict something.</span>
        <span class="k">if</span> <span class="n">new_message</span><span class="o">.</span><span class="n">priority</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="c1"># Simulate eviction by dropping oldest message</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">messages_dropped</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
</div>
<p>This broker tracks dropped messages by priority level, letting operators see which message types are being lost.
In a full implementation, you'd maintain a priority queue that allows efficient eviction of low-priority messages.
The principle remains: when backpressure occurs, preserve what matters most.</p>
<p>Kafka's partition assignment and compaction features provide a form of priority-based retention.
RabbitMQ supports priority queues natively.
Custom message brokers in high-frequency trading and real-time analytics
often implement sophisticated priority schemes.</p>
<h2>Delivery Guarantees</h2>
<p>Our implementation provides unbounded queuing, which means messages are never dropped (assuming infinite memory).
This is closer to "at-least-once" delivery,
though we haven't implemented acknowledgments or redelivery on failure.
Let's discuss the spectrum of delivery guarantees:</p>
<ul>
<li>
<p><strong>At-most-once delivery</strong> ensures that messages are delivered zero or one time—never duplicated, but possibly lost.
This is achieved by dropping messages when queues are full or when subscribers are unavailable.
It's the weakest guarantee but the simplest to implement and the fastest.</p>
</li>
<li>
<p><strong>At-least-once delivery</strong> ensures every message is delivered, possibly multiple times.
This requires acknowledgments: the broker keeps messages until subscribers confirm receipt.
If a subscriber crashes before acknowledging, the broker redelivers to another subscriber or retries.
Kafka and RabbitMQ support this mode.</p>
</li>
<li>
<p><strong>Exactly-once delivery</strong> is the strongest guarantee: each message is processed exactly once.
This is surprisingly difficult in distributed systems due to failures and network issues.
Kafka achieves this through idempotent producers and transactional consumers—essentially assigning each message a unique ID and having consumers track which IDs they've processed.</p>
</li>
</ul>
<p>Here's how we could extend our broker to support at-least-once delivery with acknowledgments:</p>
<div data-filter="inc=ackmessage" data-inc="ack_broker.py"><div class="codehilite"><pre class=""><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AckMessage</span><span class="p">(</span><span class="n">Message</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Message that requires acknowledgment."""</span>

    <span class="n">ack_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
</div>
<div data-filter="inc=ackbroker" data-inc="ack_broker.py"><div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">AckBroker</span><span class="p">(</span><span class="n">MessageBroker</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Broker with acknowledgment support."""</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">ack_timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ack_timeout</span> <span class="o">=</span> <span class="n">ack_timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_acks</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># ack_id -&gt; (message, timestamp, queue)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_ack_id</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">publish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Publish with ack tracking."""</span>
        <span class="n">queues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topics</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">for</span> <span class="n">queue</span> <span class="ow">in</span> <span class="n">queues</span><span class="p">:</span>
            <span class="n">ack_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_ack_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next_ack_id</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">ack_msg</span> <span class="o">=</span> <span class="n">AckMessage</span><span class="p">(</span>
                <span class="n">topic</span><span class="o">=</span><span class="n">message</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span>
                <span class="n">content</span><span class="o">=</span><span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">,</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">message</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                <span class="n">timestamp</span><span class="o">=</span><span class="n">message</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span>
                <span class="n">ack_id</span><span class="o">=</span><span class="n">ack_id</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pending_acks</span><span class="p">[</span><span class="n">ack_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ack_msg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
            <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">ack_msg</span><span class="p">)</span>

            <span class="c1"># Schedule re-delivery if not acknowledged.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ack_timeout</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">aid</span><span class="o">=</span><span class="n">ack_id</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_ack</span><span class="p">(</span><span class="n">aid</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">acknowledge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ack_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Acknowledge receipt of a message."""</span>
        <span class="k">if</span> <span class="n">ack_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_acks</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_acks</span><span class="p">[</span><span class="n">ack_id</span><span class="p">]</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_check_ack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ack_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Redeliver if not acknowledged."""</span>
        <span class="k">if</span> <span class="n">ack_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_acks</span><span class="p">:</span>
            <span class="n">msg</span><span class="p">,</span> <span class="n">original_time</span><span class="p">,</span> <span class="n">queue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_acks</span><span class="p">[</span><span class="n">ack_id</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">now</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">] Redelivering </span><span class="si">{</span><span class="n">msg</span><span class="o">.</span><span class="n">content</span><span class="si">}</span><span class="s2"> (ack_id </span><span class="si">{</span><span class="n">ack_id</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
            <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</code></pre></div>
</div>
<p>A subscriber using this broker would call <code>broker.acknowledge(message.ack_id)</code> after successfully processing each message.
Messages not acknowledged within the timeout would be redelivered.</p>
<h2>Consumer Groups and Load Balancing</h2>
<p>In production systems, we often want multiple instances of the same subscriber type to share the workload.
This is called a consumer group: messages on a topic are distributed among group members rather than duplicated to each.
Here's a simple implementation:</p>
<div data-filter="inc=consumer" data-inc="consumer_group.py"><div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ConsumerGroup</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Distribute messages among multiple consumers."""</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">broker</span><span class="p">:</span> <span class="n">MessageBroker</span><span class="p">,</span> <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">num_consumers</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">broker</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">topic</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consumers</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Create consumer queues for load balancing</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_consumers</span><span class="p">):</span>
            <span class="n">consumer_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">consumers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">consumer_queue</span><span class="p">)</span>

        <span class="c1"># Start distributor process</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distributor</span> <span class="o">=</span> <span class="n">_Distributor</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumers</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_consumer_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Queue</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Get queue for a specific consumer in the group."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</code></pre></div>
</div>
<div data-filter="inc=distributor" data-inc="consumer_group.py"><div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">_Distributor</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Distribute messages round-robin to consumers."""</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">destinations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Queue</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span> <span class="o">=</span> <span class="n">destinations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_dest</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Forward messages to consumers in round-robin order."""</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">next_dest</span><span class="p">]</span>
            <span class="k">await</span> <span class="n">dest</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next_dest</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">next_dest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">)</span>
</code></pre></div>
</div>
<p>This consumer group receives messages from the broker on a single queue, then distributes them round-robin to individual consumer queues.
Each consumer in the group processes a subset of the messages, enabling parallel processing.
Real systems use more sophisticated load balancing—weighted distribution, least-loaded routing, or partition-based assignment.</p>
<h2>Conclusion</h2>
<p>The publish-subscribe pattern decouples system components, enabling independent scaling and evolution.
By routing messages through a broker, we gain buffering, fan-out, and fault tolerance.
Backpressure ensures the system remains stable under load, preventing cascading failures when consumers can't keep up with producers.</p>
<p>The code we've written captures the essential ideas: topics, subscriptions, asynchronous delivery, queuing, and backpressure.
We've seen how asimpy's async/await syntax makes concurrent behavior natural to express, how bounded queues create backpressure, and how publishers can adapt to flow control signals.</p>
<p>Real systems add persistence (writing messages to disk), replication (for fault tolerance), partitioning (for parallelism), and sophisticated delivery semantics.
But the core pattern remains the same: publishers and subscribers communicate through topics, with a broker managing the complexity in between, and backpressure ensuring the system doesn't overwhelm itself.</p>
</main>
<footer>
<div class="row">
<div class="col-3 left">
	  ⇐ <a href="../intro/">Introduction</a>
</div>
<div class="col-6 center">
<a href="../"></a>
	  © 2025
	  <a href="../#acknowledgments">the authors</a>
</div>
<div class="col-3 right">
<a href="../worksteal/">Work-Stealing Scheduler</a> ⇒
	</div>
</div>
</footer>
</body>
</html>